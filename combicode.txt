You are an expert software architect. The user is providing you with the complete source code for a project, contained in a single file. Your task is to meticulously analyze the provided codebase to gain a comprehensive understanding of its structure, functionality, dependencies, and overall architecture.

A file tree is provided below to give you a high-level overview. The subsequent sections contain the full content of each file, clearly marked with "// FILE: <path>".

Your instructions are:
1.  **Analyze Thoroughly:** Read through every file to understand its purpose and how it interacts with other files.
2.  **Identify Key Components:** Pay close attention to configuration files (like package.json, pyproject.toml), entry points (like index.js, main.py), and core logic.

## Project File Tree

```
BrowserSelector/
├── .github
│   └── workflows
│       └── release.yml
├── .gitignore
├── AGENTS.MD
├── CHANGELOG.md
├── LICENSE
├── Makefile
├── README.md
├── combicode.txt
├── config.json
├── include
│   ├── cJSON.c
│   └── cJSON.h
├── resources
│   ├── app.rc
│   ├── manifest.xml
│   └── strings.rc
└── src
    ├── config
    │   ├── config.c
    │   └── config.h
    ├── executor
    │   ├── executor.c
    │   └── executor.h
    ├── i18n
    │   ├── i18n.c
    │   └── i18n.h
    ├── main.c
    ├── registry
    │   ├── registry.c
    │   └── registry.h
    └── ui
        ├── commandeditor.c
        ├── commandeditor.h
        ├── mainwindow.c
        ├── mainwindow.h
        ├── settings.c
        └── settings.h
```

---

// FILE: .github/workflows/release.yml
```
name: Release

on:
  push:
    tags:
      - 'v*'

env:
  APP_NAME: BrowserSelector
  
permissions:
  contents: write

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-gcc
            make

      - name: Build Release
        shell: msys2 {0}
        run: |
          make release

      - name: Get version from tag
        id: get_version
        shell: bash
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Create release package
        shell: pwsh
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $packageDir = "BrowserSelector"
          $zipName = "BrowserSelector-$version-win64.zip"
          
          # Create package directory
          New-Item -ItemType Directory -Force -Path $packageDir
          
          # Copy files
          Copy-Item "bin/BrowserSelector.exe" -Destination $packageDir
          ### Copy-Item "config.json" -Destination $packageDir
          ### Copy-Item "LICENSE" -Destination $packageDir
          Copy-Item "README.md" -Destination $packageDir
          
          # Create ZIP archive
          Compress-Archive -Path $packageDir -DestinationPath $zipName -Force
          
          # Calculate SHA256
          $hash = (Get-FileHash -Path $zipName -Algorithm SHA256).Hash.ToLower()
          $hash | Out-File -FilePath "$zipName.sha256" -NoNewline -Encoding ascii
          
          Write-Host "Package: $zipName"
          Write-Host "SHA256: $hash"
          
          # Store hash for later steps
          echo "HASH=$hash" >> $env:GITHUB_OUTPUT
        id: package

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            BrowserSelector-*.zip
            BrowserSelector-*.zip.sha256
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(github.ref, '-alpha') || contains(github.ref, '-beta') || contains(github.ref, '-rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Scoop bucket
        if: ${{ !contains(github.ref, '-alpha') && !contains(github.ref, '-beta') && !contains(github.ref, '-rc') }}
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.SCOOP_BUCKET_TOKEN }}
          repository: ruslan-rv-ua/scoop-bucket
          event-type: update-manifest
          client-payload: |
            {
              "version": "${{ steps.get_version.outputs.VERSION }}",
              "hash": "${{ steps.package.outputs.HASH }}",
              "url": "https://github.com/ruslan-rv-ua/BrowserSelector/releases/download/v${{ steps.get_version.outputs.VERSION }}/BrowserSelector-${{ steps.get_version.outputs.VERSION }}-win64.zip"
            }

```

// FILE: .gitignore
```
# .gitignore for BrowserSelector (C, MinGW/Makefile)

# Build directories
/obj/
/bin/
/build/
/out/

# Compiled objects and executables
*.o
*.obj
*.exe
*.dll
*.lib
*.a
*.res
*.ilk
*.pdb
*.stackdump

# cJSON build artifacts (if built locally)
cJSON/build/
lib/libcjson.a

# IDE / editor
.vscode/
.vs/
.idea/
*.suo
*.user
*.sln
*.vcxproj*
*.vcxproj.filters
*.vcxproj.user

# OS files
Thumbs.db
Desktop.ini
.DS_Store

# Temporary and backup files
*~
*.swp
*.tmp
*.log

# Coverage / profiling
coverage/
*.gcda
*.gcno

# Misc generated
obj/*.res
obj/*.o

```

// FILE: AGENTS.MD
```
# Технічна специфікація: Windows Browser Selector (C Implementation)

## Огляд проєкту
Створення портативного Windows desktop застосунку, який виступає як селектор браузерів. Коли відкривається URL, застосунок показує меню з налаштованими браузерами/командами для вибору користувачем.

## Основні вимоги

### 1. Технологічний стек
- **Мова:** C (стандарт C11)
- **Компілятор:** GCC (MinGW-w64) 8.1.0 або новіший
- **GUI Framework:** Win32 API (нативні Windows контроли)
- **Формат даних:** JSON (бібліотека cJSON)
- **Білд:** Один портативний .exe файл
- **Windows Registry:** Native Win32 Registry API
- **Криптографія:** Windows CryptoAPI (для UserChoice hash на Windows 10+)
- **i18n:** Windows String Resources (STRINGTABLE) з підтримкою Unicode

### 2. Встановлення компонентів

#### 2.1 Встановлення MinGW-w64

**Варіант 1: MSYS2 (рекомендовано)**
```bash
# Завантажити MSYS2 з https://www.msys2.org/
# Встановити MSYS2 в C:\msys64

# Відкрити MSYS2 MINGW64 terminal
pacman -Syu
pacman -S mingw-w64-x86_64-gcc
pacman -S mingw-w64-x86_64-make
pacman -S git

# Додати до PATH: C:\msys64\mingw64\bin
# Через System Properties -> Advanced -> Environment Variables
# Або через командний рядок (тимчасово):
set PATH=%PATH%;C:\msys64\mingw64\bin
```

**Варіант 2: Standalone MinGW-w64**
```
1. Завантажити з https://winlibs.com/
2. Вибрати: GCC 13.x + MinGW-w64 x86_64
3. Розпакувати в C:\mingw64
4. Додати C:\mingw64\bin до системного PATH:
   - Win+R -> sysdm.cpl -> Advanced -> Environment Variables
   - Знайти PATH -> Edit -> New -> додати C:\mingw64\bin
```

**Перевірка встановлення:**
```bash
gcc --version
# Має вивести: gcc (GCC) 13.x.x або новіше
```

#### 2.1.1 Перевірка встановлення в Windows CMD
```cmd
# Перевірити версію GCC
gcc --version

# Перевірити наявність make
make --version

# Перевірити наявність windres
windres --version
```

#### 2.1.2 Налаштування середовища Windows
```cmd
# Тимчасове налаштування PATH для поточної сесії
set PATH=%PATH%;C:\msys64\mingw64\bin

# Постійне налаштування через системні змінні:
# 1. Win+R -> sysdm.cpl -> Advanced -> Environment Variables
# 2. Знайти PATH в System variables -> Edit -> New
# 3. Додати: C:\msys64\mingw64\bin
# 4. Перезапустити командний рядок
```

#### 2.2 Встановлення cJSON бібліотеки

**Варіант 1: Компіляція з вихідників (рекомендовано)**
```bash
# Клонувати репозиторій
git clone https://github.com/DaveGamble/cJSON.git
cd cJSON

# Компілювати
mkdir build
cd build
gcc -c ../cJSON.c -o cJSON.o
ar rcs libcjson.a cJSON.o

# Копіювати файли в проєкт
# cJSON.h -> include/
# libcjson.a -> lib/
```

**Варіант 2: MSYS2**
```bash
pacman -S mingw-w64-x86_64-cjson
```

#### 2.3 Структура проєкту
```
browserselector/
├── src/
│   ├── main.c              # Точка входу
│   ├── ui/
│   │   ├── mainwindow.c    # Головне вікно
│   │   ├── mainwindow.h
│   │   ├── settings.c      # Вікно налаштувань
│   │   ├── settings.h
│   │   ├── commandeditor.c # Діалог додавання/редагування
│   │   └── commandeditor.h
│   ├── config/
│   │   ├── config.c        # Робота з конфігурацією
│   │   └── config.h
│   ├── executor/
│   │   ├── executor.c      # Запуск команд
│   │   └── executor.h
│   ├── registry/
│   │   ├── registry.c      # Реєстрація браузера
│   │   └── registry.h
│   └── i18n/
│       ├── i18n.c          # Інтернаціоналізація
│       └── i18n.h
├── include/
│   └── cJSON.h            # Заголовок cJSON
├── lib/
│   └── libcjson.a         # Статична бібліотека cJSON
├── resources/
│   ├── app.rc             # Ресурсний файл
│   ├── strings.rc         # Локалізовані рядки (всі мови)
│   └── manifest.xml       # Маніфест застосунку
├── Makefile               # Файл збірки
├── config.json            # Конфігурація за замовчуванням
└── README.md
```

### 3. Архітектура застосунку

#### 3.1 Поведінка точки входу
- Приймає URL як аргумент командного рядка: `BrowserSelector.exe "https://example.com"`
- Якщо URL не надано, браузер відкривається без URL
- Завантажує конфігурацію з `config.json` (в тій же директорії що й .exe)
- Відображає вікно вибору команди з таймером автовідкриття
- Якщо користувач не натискає жодної клавіші протягом `waitTime` секунд, автоматично відкривається браузер за замовчуванням
- Будь-яка взаємодія користувача скасовує таймер автовідкриття

#### 3.2 Структура конфігураційного файлу
**Файл:** `config.json` (зберігається поряд з .exe)

```json
{
  "settings": {
    "defaultCommandIndex": 0,
    "waitTime": 10
  },
  "commands": [
    {
      "name": "Copy to Clipboard",
      "command": "echo {url} | clip"
    },
    {
      "name": "Chrome Incognito",
      "command": "chrome.exe --incognito {url}"
    },
    {
      "name": "Firefox Profile",
      "command": "firefox.exe -P default {url}"
    },
    {
      "name": "Helium",
      "command": "helium.exe {url}"
    }
  ]
}
```

#### 3.3 Функціональність WaitTime (Автоматичне відкриття)
- **WaitTime** - час очікування в секундах перед автоматичним відкриттям браузера за замовчуванням
- Діапазон значень: 1-10 секунд
- Початкове значення за замовчуванням: 10 секунд
- При запуску застосунку відображається зворотний відлік
- Будь-яка дія користувача (натискання клавіші, клік миші) скасовує автовідкриття
- Налаштовується у вікні налаштувань

#### 3.4 Інтернаціоналізація (i18n)

**Підтримувані мови:**
| Мова | Код Windows |
|------|-------------|
| English (основна) | LANG_ENGLISH |
| Українська | LANG_UKRAINIAN |
| Німецька | LANG_GERMAN |
| Французька | LANG_FRENCH |
| Іспанська | LANG_SPANISH |
| Італійська | LANG_ITALIAN |
| Польська | LANG_POLISH |
| Нідерландська | LANG_DUTCH |
| Португальська | LANG_PORTUGUESE |

**НЕ підтримуються:** російська, китайська, японська.

**Архітектура:**
- Усі рядки зберігаються в `resources/strings.rc` як Windows STRINGTABLE
- Кожна мова має свій блок `LANGUAGE LANG_XXX, SUBLANG_DEFAULT`
- Ресурсні файли компілюються з кодовою сторінкою UTF-8 (`--codepage=65001`)
- При запуску викликається `I18n_Init(hInstance)` яка визначає мову Windows через `GetUserDefaultUILanguage()`
- Використовуються Wide-string функції Win32 API (CreateWindowExW, MessageBoxW, SetWindowTextW)

**Отримання рядків:**
```c
// Wide string (рекомендовано для Win32 UI)
const wchar_t* str = I18n_GetStringW(IDS_APP_TITLE);

// ANSI string (для сумісності)
const char* str = I18n_GetStringA(IDS_APP_TITLE);
```

**Категорії рядків:**
- 100-199: Головне вікно
- 200-299: Вікно налаштувань
- 300-399: Редактор команд
- 400-499: Повідомлення про помилки
- 500-599: Реєстрація браузера
- 600-699: Основні повідомлення застосунку

### 4. Структури даних

#### 4.1 Основні структури (config/config.h)
```c
#ifndef CONFIG_H
#define CONFIG_H

#define MAX_PATH_LENGTH 260
#define MAX_NAME_LENGTH 100
#define MAX_COMMANDS 50

typedef struct {
    char name[MAX_NAME_LENGTH];
    char command[MAX_PATH_LENGTH];
} Command;

typedef struct {
    int defaultCommandIndex;
    int waitTime;
} Settings;

typedef struct {
    Settings settings;
    Command commands[MAX_COMMANDS];
    int commandCount;
} Configuration;

// Функції для роботи з конфігурацією
int LoadConfig(const char* exePath, Configuration* config);
int SaveConfig(const char* exePath, const Configuration* config);
int CreateDefaultConfig(const char* configPath);

#endif // CONFIG_H
```

#### 4.2 UI структури (ui/mainwindow.h)
```c
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <windows.h>
#include "../config/config.h"

typedef struct {
    HWND hwnd;
    HWND listBox;
    HWND registerBtn;
    HWND settingsBtn;
    HWND countdownLabel;
    Configuration* config;
    char* url;
    char exePath[MAX_PATH];
    HINSTANCE hInstance;
    UINT_PTR timerId;
    int remainingSeconds;
    int timerActive;
} MainWindow;

HWND CreateMainWindow(HINSTANCE hInstance, Configuration* config, const char* url, const char* exePath);
LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#endif // MAINWINDOW_H
```

### 5. Реалізація основних компонентів

#### 5.1 Точка входу (src/main.c)
```c
#include <windows.h>
#include <stdio.h>
#include "config/config.h"
#include "ui/mainwindow.h"

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                   LPSTR lpCmdLine, int nCmdShow) {
    // Отримати шлях до executable
    char exePath[MAX_PATH];
    GetModuleFileNameA(NULL, exePath, MAX_PATH);
    
    // Завантажити конфігурацію
    Configuration config;
    if (!LoadConfig(exePath, &config)) {
        MessageBoxA(NULL, "Failed to load configuration", "Error", MB_OK | MB_ICONERROR);
        return 1;
    }
    
    // Отримати URL з командного рядка
    char* url = NULL;
    if (lpCmdLine && strlen(lpCmdLine) > 0) {
        // Прибрати лапки якщо є
        if (lpCmdLine[0] == '"') {
            url = lpCmdLine + 1;
            char* end = strrchr(url, '"');
            if (end) *end = '\0';
        } else {
            url = lpCmdLine;
        }
    }
    
    // Створити головне вікно
    HWND hwnd = CreateMainWindow(hInstance, &config, url);
    if (!hwnd) {
        MessageBoxA(NULL, "Failed to create window", "Error", MB_OK | MB_ICONERROR);
        return 1;
    }
    
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    
    // Цикл обробки повідомлень
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return (int)msg.wParam;
}
```

#### 5.2 Робота з конфігурацією (src/config/config.c)
```c
#include "config.h"
#include "../../include/cJSON.h"
#include <stdio.h>
#include <string.h>
#include <windows.h>

int LoadConfig(const char* exePath, Configuration* config) {
    // Отримати директорію exe
    char configPath[MAX_PATH];
    strcpy(configPath, exePath);
    char* lastSlash = strrchr(configPath, '\\');
    if (lastSlash) {
        *(lastSlash + 1) = '\0';
        strcat(configPath, "config.json");
    }
    
    // Спробувати відкрити файл
    FILE* file = fopen(configPath, "r");
    if (!file) {
        // Створити конфігурацію за замовчуванням
        return CreateDefaultConfig(configPath);
    }
    
    // Прочитати файл
    fseek(file, 0, SEEK_END);
    long fileSize = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    char* jsonString = (char*)malloc(fileSize + 1);
    fread(jsonString, 1, fileSize, file);
    jsonString[fileSize] = '\0';
    fclose(file);
    
    // Парсити JSON
    cJSON* json = cJSON_Parse(jsonString);
    free(jsonString);
    
    if (!json) {
        return 0;
    }
    
    // Зчитати settings
    cJSON* settings = cJSON_GetObjectItem(json, "settings");
    if (settings) {
        cJSON* defaultIndex = cJSON_GetObjectItem(settings, "defaultCommandIndex");
        
        config->settings.defaultCommandIndex = defaultIndex ? defaultIndex->valueint : 0;
    }
    
    // Зчитати commands
    cJSON* commands = cJSON_GetObjectItem(json, "commands");
    if (commands) {
        config->commandCount = 0;
        cJSON* command = NULL;
        cJSON_ArrayForEach(command, commands) {
            if (config->commandCount >= MAX_COMMANDS) break;
            
            cJSON* name = cJSON_GetObjectItem(command, "name");
            cJSON* cmd = cJSON_GetObjectItem(command, "command");
            
            if (name && cmd) {
                strncpy(config->commands[config->commandCount].name,
                       name->valuestring, MAX_NAME_LENGTH - 1);
                strncpy(config->commands[config->commandCount].command,
                       cmd->valuestring, MAX_PATH_LENGTH - 1);
                config->commandCount++;
            }
        }
    }
    
    cJSON_Delete(json);
    return 1;
}

int SaveConfig(const char* exePath, const Configuration* config) {
    // Отримати шлях до config.json
    char configPath[MAX_PATH];
    strcpy(configPath, exePath);
    char* lastSlash = strrchr(configPath, '\\');
    if (lastSlash) {
        *(lastSlash + 1) = '\0';
        strcat(configPath, "config.json");
    }
    
    // Створити JSON об'єкт
    cJSON* json = cJSON_CreateObject();
    
    // Додати settings
    cJSON* settings = cJSON_CreateObject();
    cJSON_AddNumberToObject(settings, "defaultCommandIndex", 
                           config->settings.defaultCommandIndex);
    cJSON_AddItemToObject(json, "settings", settings);
    
    // Додати commands
    cJSON* commands = cJSON_CreateArray();
    for (int i = 0; i < config->commandCount; i++) {
        cJSON* command = cJSON_CreateObject();
        cJSON_AddStringToObject(command, "name", config->commands[i].name);
        cJSON_AddStringToObject(command, "command", config->commands[i].command);
        cJSON_AddItemToArray(commands, command);
    }
    cJSON_AddItemToObject(json, "commands", commands);
    
    // Записати в файл
    char* jsonString = cJSON_Print(json);
    FILE* file = fopen(configPath, "w");
    if (file) {
        fputs(jsonString, file);
        fclose(file);
    }
    
    cJSON_free(jsonString);
    cJSON_Delete(json);
    
    return file != NULL;
}

int CreateDefaultConfig(const char* configPath) {
    Configuration config;
    config.settings.defaultCommandIndex = 0;
    config.commandCount = 4;
    
    strcpy(config.commands[0].name, "Copy to Clipboard");
    strcpy(config.commands[0].command, "echo {url} | clip");
    
    strcpy(config.commands[1].name, "Chrome Incognito");
    strcpy(config.commands[1].command, "chrome.exe --incognito {url}");
    
    strcpy(config.commands[2].name, "Firefox Profile");
    strcpy(config.commands[2].command, "firefox.exe -P default {url}");
    
    strcpy(config.commands[3].name, "Helium");
    strcpy(config.commands[3].command, "helium.exe {url}");
    
    return SaveConfig(configPath, &config);
}
```

#### 5.3 Головне вікно (src/ui/mainwindow.c)
```c
#include "mainwindow.h"
#include "../executor/executor.h"
#include "settings.h"

#define ID_LISTBOX 1001
#define ID_SETTINGS_BTN 1002

HWND CreateMainWindow(HINSTANCE hInstance, Configuration* config, const char* url) {
    // Реєстрація класу вікна
    WNDCLASSEXA wc = {0};
    wc.cbSize = sizeof(WNDCLASSEXA);
    wc.lpfnWndProc = MainWindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = "BrowserSelectorClass";
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    
    RegisterClassExA(&wc);
    
    // Створити структуру вікна
    MainWindow* mainWin = (MainWindow*)malloc(sizeof(MainWindow));
    mainWin->config = config;
    mainWin->url = url ? _strdup(url) : NULL;
    
    // Створити вікно
    HWND hwnd = CreateWindowExA(
        0,
        "BrowserSelectorClass",
        "Browser Selector",
        WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX & ~WS_THICKFRAME,
        CW_USEDEFAULT, CW_USEDEFAULT,
        400,
        300,
        NULL, NULL, hInstance, mainWin
    );
    
    return hwnd;
}

LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    MainWindow* mainWin = (MainWindow*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (msg) {
        case WM_CREATE: {
            CREATESTRUCT* cs = (CREATESTRUCT*)lParam;
            mainWin = (MainWindow*)cs->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)mainWin);
            mainWin->hwnd = hwnd;
            
            // Створити ListBox
            mainWin->listBox = CreateWindowExA(
                WS_EX_CLIENTEDGE,
                "LISTBOX",
                NULL,
                WS_CHILD | WS_VISIBLE | WS_VSCROLL | LBS_NOTIFY,
                10, 10, 360, 200,
                hwnd, (HMENU)ID_LISTBOX, cs->hInstance, NULL
            );
            
            // Заповнити ListBox командами
            for (int i = 0; i < mainWin->config->commandCount; i++) {
                SendMessageA(mainWin->listBox, LB_ADDSTRING, 0, 
                           (LPARAM)mainWin->config->commands[i].name);
            }
            
            // Встановити вибір за замовчуванням
            SendMessage(mainWin->listBox, LB_SETCURSEL, 
                       mainWin->config->settings.defaultCommandIndex, 0);
            
            // Створити кнопку Settings
            mainWin->settingsBtn = CreateWindowExA(
                0,
                "BUTTON",
                "Settings",
                WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                140, 220, 100, 30,
                hwnd, (HMENU)ID_SETTINGS_BTN, cs->hInstance, NULL
            );
            
            // Встановити фокус на ListBox
            SetFocus(mainWin->listBox);
            
            break;
        }
        
        case WM_COMMAND: {
            if (LOWORD(wParam) == ID_LISTBOX) {
                if (HIWORD(wParam) == LBN_DBLCLK) {
                    // Подвійний клік - виконати команду
                    int index = (int)SendMessage(mainWin->listBox, LB_GETCURSEL, 0, 0);
                    if (index != LB_ERR) {
                        ExecuteCommand(&mainWin->config->commands[index], 
                                     mainWin->url);
                        DestroyWindow(hwnd);
                    }
                }
            } else if (LOWORD(wParam) == ID_SETTINGS_BTN) {
                // Відкрити вікно налаштувань
                ShowSettingsWindow(hwnd, mainWin->config);
            }
            break;
        }
        
        case WM_KEYDOWN: {
            switch (wParam) {
                case VK_RETURN: {
                    // Enter - виконати вибрану команду
                    HWND focused = GetFocus();
                    if (focused == mainWin->listBox) {
                        int index = (int)SendMessage(mainWin->listBox, LB_GETCURSEL, 0, 0);
                        if (index != LB_ERR) {
                            ExecuteCommand(&mainWin->config->commands[index], 
                                         mainWin->url);
                            DestroyWindow(hwnd);
                        }
                    }
                    break;
                }
                case VK_ESCAPE:
                    DestroyWindow(hwnd);
                    break;
                case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9': {
                    // Швидкий вибір 1-9
                    int index = wParam - '1';
                    if (index < mainWin->config->commandCount) {
                        ExecuteCommand(&mainWin->config->commands[index], 
                                     mainWin->url);
                        DestroyWindow(hwnd);
                    }
                    break;
                }
            }
            break;
        }
        
        case WM_DESTROY:
            if (mainWin) {
                if (mainWin->url) free(mainWin->url);
                free(mainWin);
            }
            PostQuitMessage(0);
            break;
            
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    
    return 0;
}
```

#### 5.4 Виконувач команд (src/executor/executor.c)
```c
#include "executor.h"
#include <string.h>
#include <windows.h>

static char* ReplaceUrlPlaceholder(const char* arguments, const char* url) {
    if (!url) url = "";
    
    // Підрахувати розмір результату
    const char* pos = strstr(arguments, "{url}");
    if (!pos) {
        return _strdup(arguments);
    }
    
    size_t resultSize = strlen(arguments) - 5 + strlen(url) + 1;
    char* result = (char*)malloc(resultSize);
    
    // Скопіювати частину до {url}
    size_t prefixLen = pos - arguments;
    strncpy(result, arguments, prefixLen);
    result[prefixLen] = '\0';
    
    // Додати URL
    strcat(result, url);
    
    // Додати частину після {url}
    strcat(result, pos + 5);
    
    return result;
}

static char* ResolveCommand(const char* command) {
    char resolved[MAX_PATH];
    
    // Перевірити чи це абсолютний шлях
    if (strchr(command, ':') || command[0] == '\\') {
        DWORD attrs = GetFileAttributesA(command);
        if (attrs != INVALID_FILE_ATTRIBUTES) {
            return _strdup(command);
        }
        return NULL;
    }
    
    // Перевірити чи це відносний шлях
    if (strchr(command, '\\') || strchr(command, '/')) {
        char exePath[MAX_PATH];
        GetModuleFileNameA(NULL, exePath, MAX_PATH);
        char* lastSlash = strrchr(exePath, '\\');
        if (lastSlash) {
            *lastSlash = '\0';
            sprintf(resolved, "%s\\%s", exePath, command);
            
            DWORD attrs = GetFileAttributesA(resolved);
            if (attrs != INVALID_FILE_ATTRIBUTES) {
                return _strdup(resolved);
            }
        }
        return NULL;
    }
    
    // Шукати в PATH
    if (SearchPathA(NULL, command, ".exe", MAX_PATH, resolved, NULL)) {
        return _strdup(resolved);
    }
    
    return NULL;
}

int ExecuteCommand(const Command* command, const char* url) {
    // Підготувати повну команду з заміною {url}
    char* fullCommand = ReplaceUrlPlaceholder(command->command, url);
    
    // Підготувати command line для cmd.exe /c
    char cmdLine[2048];
    sprintf(cmdLine, "cmd.exe /c \"%s\"", fullCommand);
    
    // Запустити процес
    STARTUPINFOA si = {0};
    PROCESS_INFORMATION pi = {0};
    si.cb = sizeof(si);
    
    BOOL success = CreateProcessA(
        NULL,           // lpApplicationName
        cmdLine,        // lpCommandLine
        NULL,           // lpProcessAttributes
        NULL,           // lpThreadAttributes
        FALSE,          // bInheritHandles
        0,              // dwCreationFlags
        NULL,           // lpEnvironment
        NULL,           // lpCurrentDirectory
        &si,            // lpStartupInfo
        &pi             // lpProcessInformation
    );
    
    if (success) {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    } else {
        char error[512];
        sprintf(error, "Failed to launch: %s\nError code: %lu",
                command->command, GetLastError());
        MessageBoxA(NULL, error, "Error", MB_OK | MB_ICONERROR);
    }
    
    free(fullCommand);
    
    return success;
}
```

### 6. Компіляція та збірка

#### 6.1 Makefile
```makefile
# Compiler settings
CC = gcc
WINDRES = windres
CFLAGS = -std=c11 -Wall -Wextra -O2 -Iinclude
LDFLAGS = -mwindows -static-libgcc -static
LIBS = -lcomctl32 -ladvapi32 -lshell32 -luser32 -lgdi32 -lkernel32 -Llib -lcjson

# Directories
SRC_DIR = src
OBJ_DIR = obj
BIN_DIR = bin

# Source files
SOURCES = $(SRC_DIR)/main.c \
          $(SRC_DIR)/config/config.c \
          $(SRC_DIR)/ui/mainwindow.c \
          $(SRC_DIR)/ui/settings.c \
          $(SRC_DIR)/ui/commandeditor.c \
          $(SRC_DIR)/executor/executor.c \
          $(SRC_DIR)/registry/registry.c

# Object files
OBJECTS = $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SOURCES))
RESOURCE_OBJ = $(OBJ_DIR)/app.res

# Target executable
TARGET = $(BIN_DIR)/BrowserSelector.exe

# Default target
all: directories $(TARGET)

# Create directories
directories:
	@if not exist "$(OBJ_DIR)" mkdir "$(OBJ_DIR)"
	@if not exist "$(OBJ_DIR)\config" mkdir "$(OBJ_DIR)\config"
	@if not exist "$(OBJ_DIR)\ui" mkdir "$(OBJ_DIR)\ui"
	@if not exist "$(OBJ_DIR)\executor" mkdir "$(OBJ_DIR)\executor"
	@if not exist "$(OBJ_DIR)\registry" mkdir "$(OBJ_DIR)\registry"
	@if not exist "$(BIN_DIR)" mkdir "$(BIN_DIR)"

# Compile C files
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	$(CC) $(CFLAGS) -c $< -o $@

# Compile resource file
$(RESOURCE_OBJ): resources/app.rc
	$(WINDRES) -i resources/app.rc -o $(RESOURCE_OBJ)

# Link executable
$(TARGET): $(OBJECTS) $(RESOURCE_OBJ)
	$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)
	@echo Build complete: $(TARGET)

# Clean build files
clean:
	@if exist "$(OBJ_DIR)" rmdir /s /q "$(OBJ_DIR)"
	@if exist "$(BIN_DIR)" rmdir /s /q "$(BIN_DIR)"
	@echo Clean complete

# Release build (optimized, stripped)
release: CFLAGS += -DNDEBUG
release: LDFLAGS += -s
release: clean all
	@echo Release build complete

# Run the application
run: all
	$(TARGET)

.PHONY: all clean release run directories
```

#### 6.2 Ресурсний файл (resources/app.rc)
```rc
#include <windows.h>

// Application icon
1 ICON "app.ico"

// Version information
VS_VERSION_INFO VERSIONINFO
FILEVERSION     1,0,0,0
PRODUCTVERSION  1,0,0,0
FILEFLAGSMASK   0x3fL
FILEFLAGS       0x0L
FILEOS          VOS_NT_WINDOWS32
FILETYPE        VFT_APP
FILESUBTYPE     VFT2_UNKNOWN
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName",      "Your Company\0"
            VALUE "FileDescription",  "Browser Selector\0"
            VALUE "FileVersion",      "1.0.0.0\0"
            VALUE "InternalName",     "BrowserSelector\0"
            VALUE "LegalCopyright",   "Copyright (C) 2025\0"
            VALUE "OriginalFilename", "BrowserSelector.exe\0"
            VALUE "ProductName",      "Browser Selector\0"
            VALUE "ProductVersion",   "1.0.0.0\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

// Application manifest
1 RT_MANIFEST "manifest.xml"
```

#### 6.3 Маніфест (resources/manifest.xml)
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <assemblyIdentity
    version="1.0.0.0"
    processorArchitecture="*"
    name="BrowserSelector"
    type="win32"/>
  <description>Browser Selector Application</description>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
        type="win32"
        name="Microsoft.Windows.Common-Controls"
        version="6.0.0.0"
        processorArchitecture="*"
        publicKeyToken="6595b64144ccf1df"
        language="*"/>
    </dependentAssembly>
  </dependency>
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
```

### 7. Інструкції по компіляції

#### 7.1 Базова компіляція
```cmd
:: Збірка проєкту
make

:: Збірка release версії (оптимізована, без debug символів)
make release

:: Очистити build файли
make clean

:: Збірка та запуск
make run
```

#### 7.2 Ручна компіляція (без Makefile)
```bash
# Компілювати всі .c файли
gcc -c -Iinclude src/main.c -o obj/main.o
gcc -c -Iinclude src/config/config.c -o obj/config.o
gcc -c -Iinclude src/ui/mainwindow.c -o obj/mainwindow.o
gcc -c -Iinclude src/ui/settings.c -o obj/settings.o
gcc -c -Iinclude src/ui/commandeditor.c -o obj/commandeditor.o
gcc -c -Iinclude src/executor/executor.c -o obj/executor.o
gcc -c -Iinclude src/registry/registry.c -o obj/registry.o

# Скомпілювати ресурси
windres -i resources/app.rc -o obj/app.res

# Зібрати executable
gcc -mwindows -static-libgcc -static -o bin/BrowserSelector.exe \
    obj/main.o obj/config.o obj/mainwindow.o obj/settings.o \
    obj/commandeditor.o obj/executor.o obj.registry.o obj/app.res \
    -Llib -lcjson -lcomctl32 -ladvapi32 -lshell32 -luser32 -lgdi32 -lkernel32

# Додатково: strip для зменшення розміру
strip bin/BrowserSelector.exe
```

#### 7.3 Оптимізації розміру
```cmd
:: Компіляція з максимальною оптимізацією розміру
gcc -Os -s -mwindows -static-libgcc -static -Iinclude ^
    src/main.c src/config/*.c src/ui/*.c ^
    src/executor/*.c src/registry/*.c ^
    obj/app.res -o bin/BrowserSelector.exe ^
    -Llib -lcjson -lcomctl32 -ladvapi32 -lshell32 -luser32 -lgdi32 -lkernel32

:: Стиснення UPX (опціонально)
upx --best --lzma bin/BrowserSelector.exe
```

### 8. Тестування

#### 8.1 Підготовка тестового середовища Windows
```cmd
# Переконатись що всі інструменти доступні
where gcc
where make
where windres

# Перевірити структуру проєкту
dir /s src\
dir include\
dir lib\
dir resources\
```

#### 8.2 Тестові команди
```cmd
:: Тест без URL
bin\BrowserSelector.exe

:: Тест з простим URL
bin\BrowserSelector.exe "https://google.com"

:: Тест з URL що містить спецсимволи
bin\BrowserSelector.exe "https://example.com/search?q=test&lang=uk"

:: Тест з довгим URL
bin\BrowserSelector.exe "https://example.com/very/long/path/with/many/segments?param1=value1&param2=value2"

:: Тест з локальним файлом
bin\BrowserSelector.exe "file:///C:/Users/Test/Desktop/index.html"

:: Тест з URL що містить пробіли
bin\BrowserSelector.exe "https://example.com/search?q=test query"
```

#### 8.3 Перевірка конфігурації
```json
// Тестовий config.json з різними типами шляхів
{
  "settings": {
    "defaultCommandIndex": 0,
    "waitTime": 10
  },
  "commands": [
    {
      "name": "Copy to Clipboard",
      "command": "echo {url} | clip"
    },
    {
      "name": "Chrome Incognito (PATH)",
      "command": "chrome.exe --incognito {url}"
    },
    {
      "name": "Firefox (absolute)",
      "command": "C:\\Program Files\\Mozilla Firefox\\firefox.exe -P default {url}"
    },
    {
      "name": "Custom (relative)",
      "command": "..\\browsers\\custom.exe {url}"
    }
  ]
}
```

### 9. Чеклист функціональності

- [x] Компіляція без помилок
- [x] Запуск з URL аргументом
- [x] Запуск без URL
- [x] Завантаження config.json
- [x] Створення конфігурації за замовчуванням
- [x] Відображення головного вікна
- [x] Відображення кнопки "Set as Default"/"Unregister" з правильним текстом залежно від статусу
- [x] Вибір команди мишею
- [x] Вибір команди клавіатурою (Enter)
- [x] Навігація стрілками
- [x] Швидкий вибір 1-9
- [x] Реєстрація та встановлення як браузер за замовчуванням через кнопку "Set as Default"
- [x] Перевірка чи застосунок вже є браузером за замовчуванням
- [x] Видалення реєстрації через кнопку "Unregister"
- [x] Оновлення тексту кнопки після зміни статусу
- [x] Відкриття Windows Settings для ручного вибору (на Windows 10+)
- [x] Відкриття вікна налаштувань
- [x] Додавання нової команди
- [x] Редагування команди
- [x] Видалення команди
- [x] Зміна порядку команд
- [x] Збереження налаштувань
- [x] Виконання команди з PATH
- [x] Виконання команди з абсолютним шляхом
- [x] Виконання команди з відносним шляхом
- [x] Обробка помилок (команда не знайдена)
- [x] Робота з Unicode шляхами
- [x] Обробка спеціальних символів в URL
- [x] WaitTime функціональність:
  - [x] Автоматичне відкриття браузера за замовчуванням після закінчення таймера
  - [x] Відображення зворотного відліку в головному вікні
  - [x] Скасування таймера при будь-якій дії користувача
  - [x] Налаштування WaitTime в діалозі налаштувань (діапазон 1-10 секунд)
  - [x] Валідація значень WaitTime
  - [x] Збереження/завантаження WaitTime в config.json
- [x] i18n (інтернаціоналізація):
  - [x] Локалізовані рядки вшиті в exe файл (Windows STRINGTABLE)
  - [x] Автоматичне визначення мови Windows UI при старті
  - [x] Підтримка 9 мов: English, Ukrainian, German, French, Spanish, Italian, Polish, Dutch, Portuguese
  - [x] Fallback на English якщо мова не підтримується
  - [x] Коректне відображення Unicode символів (UTF-16)

### 10. Поширені проблеми та рішення

#### 10.1 Проблеми з встановленням Windows

**Проблема:** Команди gcc, make не розпізнаються
```cmd
# Рішення: Перевірити PATH
echo %PATH%

# Якщо шлях відсутній, додати тимчасово:
set PATH=%PATH%;C:\msys64\mingw64\bin

# Або постійно через System Properties
```

**Проблема:** Помилка "cannot find -lcjson"
```cmd
# Рішення: Перевірити наявність бібліотеки
dir lib\libcjson.a

# Якщо відсутня, скомпілювати cJSON:
git clone https://github.com/DaveGamble/cJSON.git
cd cJSON
mkdir build
cd build
gcc -c ../cJSON.c -o cJSON.o
ar rcs libcjson.a cJSON.o
copy ..\cJSON.h ..\..\include\
copy libcjson.a ..\..\lib\
```

#### 10.2 Помилки компіляції

**Проблема:** `cJSON.h: No such file or directory`
```bash
# Рішення: Перевірити шляхи до include
gcc -Iinclude ...
# Або скопіювати cJSON.h в include/
```

**Проблема:** `undefined reference to 'cJSON_Parse'`
```bash
# Рішення: Додати -lcjson до лінкування
gcc ... -Llib -lcjson
```

**Проблема:** Вікно консолі з'являється
```bash
# Рішення: Використовувати -mwindows
gcc -mwindows ...
```

#### 10.3 Помилки виконання

**Проблема:** "Failed to load configuration"
- Перевірити чи config.json в тій же директорії що й .exe
- Перевірити синтаксис JSON
- Перевірити права доступу до файлу

**Проблема:** "Command not found"
- Перевірити чи команда в PATH
- Використовувати абсолютний шлях
- Перевірити чи існує файл

### 11. Додаткові можливості

#### 11.1 Іконка застосунку
```cmd
# Створити .ico файл з PNG
# Варіант 1: ImageMagick (потрібно встановити)
magick convert icon.png -define icon:auto-resize=256,128,64,48,32,16 app.ico

# Варіант 2: Онлайн сервіс
# https://convertio.co/png-ico/ або https://www.icoconverter.com/

# Варіант 3: GIMP (безкоштовний редактор)
# Відкрити PNG -> File -> Export As -> вибрати .ico формат
```

#### 11.2 Цифровий підпис
```cmd
# Використовувати signtool.exe з Windows SDK
# Зазвичай знаходиться в C:\Program Files (x86)\Windows Kits\10\bin\<version>\x64\
signtool sign /f certificate.pfx /p password /t http://timestamp.digicert.com BrowserSelector.exe

# Альтернативно використовувати timestamp сервер:
signtool sign /f certificate.pfx /p password /tr http://timestamp.digicert.com /td sha256 /fd sha256 BrowserSelector.exe
```

### 12. Критерії успіху

Проєкт завершений коли:
1. ✅ Один .exe файл (статично слінкований)
2. ✅ Конфігурація в JSON поряд з exe
3. ✅ Вибір браузера клавіатурою (стрілки + Enter)
4. ✅ Tab переключає між ListBox та кнопками
5. ✅ Вікно налаштувань дозволяє керувати командами
6. ✅ Команда за замовчуванням обрана при запуску
7. ✅ URL коректно передається в браузер
8. ✅ Працює з NVDA та Windows Narrator
9. ✅ Обробка помилок (відсутні файли, невірні шляхи)
10. ✅ Розумна кнопка "Set as Default"/"Unregister" з автоматичною перевіркою статусу
11. ✅ Відсутнє вікно консолі
12. ✅ Малий розмір (~500KB-1MB зі статичним лінкуванням)
13. ✅ WaitTime функціональність з автоматичним відкриттям та зворотним відліком

## Додаткові ресурси

### Документація
- Win32 API: https://learn.microsoft.com/en-us/windows/win32/api/
- GCC Manual: https://gcc.gnu.org/onlinedocs/
- cJSON: https://github.com/DaveGamble/cJSON
- MinGW-w64: https://www.mingw-w64.org/

### Корисні інструменти
- Resource Hacker: Перегляд/редагування ресурсів .exe
- Dependency Walker: Перевірка залежностей DLL
- Process Monitor: Моніторинг файлових операцій
- UPX: Стиснення виконуваних файлів

#### 12.1 Windows-специфічні інструменти
```cmd
# Перевірка залежностей .exe
dumpbin /dependents bin\BrowserSelector.exe

# Аналізатор продуктивності
# Win+R -> perfmon

# Моніторинг реєстру Windows
# Win+R -> regedit

# Перевірка цифрового підпису
signtool verify /pa bin\BrowserSelector.exe
```

#### 12.2 Інтеграція з Windows

#### 12.2.1 Реєстрація як браузер за замовчуванням
```reg
Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\BrowserSelector]
@="URL:BrowserSelector Protocol"
"URL Protocol"=""

[HKEY_CLASSES_ROOT\BrowserSelector\shell]

[HKEY_CLASSES_ROOT\BrowserSelector\shell\open]

[HKEY_CLASSES_ROOT\BrowserSelector\shell\open\command]
@="\"C:\\Program Files\\BrowserSelector\\BrowserSelector.exe\" \"%1\""
```

#### 12.2.2 Додавання до контекстного меню
```reg
Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\http\shell\BrowserSelector]
@="Open with Browser Selector"

[HKEY_CLASSES_ROOT\http\shell\BrowserSelector\command]
@="\"C:\\Program Files\\BrowserSelector\\BrowserSelector.exe\" \"%1\""

[HKEY_CLASSES_ROOT\https\shell\BrowserSelector]
@="Open with Browser Selector"

[HKEY_CLASSES_ROOT\https\shell\BrowserSelector\command]
@="\"C:\\Program Files\\BrowserSelector\\BrowserSelector.exe\" \"%1\""
```
```

// FILE: CHANGELOG.md
```
# Change Log

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Changed
- **BREAKING**: Simplified configuration format - removed `arguments` field, now command and arguments are combined in single `command` field
  - Old format: `{"name": "Chrome", "command": "chrome.exe", "arguments": "{url}"}`
  - New format: `{"name": "Chrome", "command": "chrome.exe {url}"}`
- Commands are now executed via `cmd.exe /c` which enables shell features like pipes and redirects
- **Updated default commands**:
  1. Copy to Clipboard - `echo {url} | clip`
  2. Chrome Incognito - `chrome.exe --incognito {url}`
  3. Firefox Profile - `firefox.exe -P default {url}`
  4. Helium - `helium.exe {url}`
- **Improved config error handling**: If config file exists but is corrupted/invalid, user is now asked whether to create new default config or exit. If config file doesn't exist, default config is created silently.

### Added
- "Copy to Clipboard" as the first command (`echo {url} | clip`)

## [0.1.2] - 2025-12-22

### Added
- Scoop package manager support and publishing guide

### Fixed
- Removed unused static variables and window class constants to eliminate compiler warnings

## [0.1.1] - 2025-12-22

### Added
- Accessibility features including keyboard navigation and screen reader support
- Auto-open timer with countdown display functionality
- Comprehensive i18n support for English, Ukrainian, German, French, Spanish, Italian, Polish, Dutch, Portuguese

### Changed
- Improved documentation clarity
- Added project logo to README

### Fixed
- Registry warning by casting GetProcAddress return value to uintptr_t
- Focus handling after window activation

## [0.1.0] - 2024-12-20

### Added
- Initial implementation of browser selector application with Windows GUI

---

## Development Notes

### Key Features Implemented
- **Accessibility**: Full keyboard navigation, screen reader support, Tab focus handling
- **Internationalization**: Support for 9 languages (English, Ukrainian, German, French, Spanish, Italian, Polish, Dutch, Portuguese)
- **Auto-open Timer**: Configurable wait time (1-10 seconds) with countdown display
- **Smart Registration**: Automatic detection of current default browser status
- **Security**: Safe string operations, proper memory management
- **Portability**: Single executable file with embedded resources

```

// FILE: combicode.txt
```

```

// FILE: config.json
```
{
	"settings":	{
		"defaultCommandIndex":	3,
		"waitTime":	10
	},
	"commands":	[{
			"name":	"Copy to Clipboard",
			"command":	"echo {url} | clip"
		}, {
			"name":	"Chrome Incognito",
			"command":	"chrome.exe --incognito {url}"
		}, {
			"name":	"Firefox Profile",
			"command":	"firefox.exe -P default {url}"
		}, {
			"name":	"Helium",
			"command":	"helium.exe {url}"
		}]
}
```

// FILE: include/cJSON.c
```
/*
  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

/* cJSON */
/* JSON parser in C. */

/* disable warnings about old C89 functions in MSVC */
#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
#define _CRT_SECURE_NO_DEPRECATE
#endif

#ifdef __GNUC__
#pragma GCC visibility push(default)
#endif
#if defined(_MSC_VER)
#pragma warning (push)
/* disable warning about single line comments in system headers */
#pragma warning (disable : 4001)
#endif

#include <string.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <float.h>

#ifdef ENABLE_LOCALES
#include <locale.h>
#endif

#if defined(_MSC_VER)
#pragma warning (pop)
#endif
#ifdef __GNUC__
#pragma GCC visibility pop
#endif

#include "cJSON.h"

/* define our own boolean type */
#ifdef true
#undef true
#endif
#define true ((cJSON_bool)1)

#ifdef false
#undef false
#endif
#define false ((cJSON_bool)0)

/* define isnan and isinf for ANSI C, if in C99 or above, isnan and isinf has been defined in math.h */
#ifndef isinf
#define isinf(d) (isnan((d - d)) && !isnan(d))
#endif
#ifndef isnan
#define isnan(d) (d != d)
#endif

#ifndef NAN
#ifdef _WIN32
#define NAN sqrt(-1.0)
#else
#define NAN 0.0/0.0
#endif
#endif

typedef struct {
    const unsigned char *json;
    size_t position;
} error;
static error global_error = { NULL, 0 };

CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
{
    return (const char*) (global_error.json + global_error.position);
}

CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item)
{
    if (!cJSON_IsString(item))
    {
        return NULL;
    }

    return item->valuestring;
}

CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item)
{
    if (!cJSON_IsNumber(item))
    {
        return (double) NAN;
    }

    return item->valuedouble;
}

/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 19)
    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
#endif

CJSON_PUBLIC(const char*) cJSON_Version(void)
{
    static char version[15];
    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);

    return version;
}

/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
{
    if ((string1 == NULL) || (string2 == NULL))
    {
        return 1;
    }

    if (string1 == string2)
    {
        return 0;
    }

    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
    {
        if (*string1 == '\0')
        {
            return 0;
        }
    }

    return tolower(*string1) - tolower(*string2);
}

typedef struct internal_hooks
{
    void *(CJSON_CDECL *allocate)(size_t size);
    void (CJSON_CDECL *deallocate)(void *pointer);
    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
} internal_hooks;

#if defined(_MSC_VER)
/* work around MSVC error C2322: '...' address of dllimport '...' is not static */
static void * CJSON_CDECL internal_malloc(size_t size)
{
    return malloc(size);
}
static void CJSON_CDECL internal_free(void *pointer)
{
    free(pointer);
}
static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
{
    return realloc(pointer, size);
}
#else
#define internal_malloc malloc
#define internal_free free
#define internal_realloc realloc
#endif

/* strlen of character literals resolved at compile time */
#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))

static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };

static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
{
    size_t length = 0;
    unsigned char *copy = NULL;

    if (string == NULL)
    {
        return NULL;
    }

    length = strlen((const char*)string) + sizeof("");
    copy = (unsigned char*)hooks->allocate(length);
    if (copy == NULL)
    {
        return NULL;
    }
    memcpy(copy, string, length);

    return copy;
}

CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
{
    if (hooks == NULL)
    {
        /* Reset hooks */
        global_hooks.allocate = malloc;
        global_hooks.deallocate = free;
        global_hooks.reallocate = realloc;
        return;
    }

    global_hooks.allocate = malloc;
    if (hooks->malloc_fn != NULL)
    {
        global_hooks.allocate = hooks->malloc_fn;
    }

    global_hooks.deallocate = free;
    if (hooks->free_fn != NULL)
    {
        global_hooks.deallocate = hooks->free_fn;
    }

    /* use realloc only if both free and malloc are used */
    global_hooks.reallocate = NULL;
    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
    {
        global_hooks.reallocate = realloc;
    }
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
{
    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
    if (node)
    {
        memset(node, '\0', sizeof(cJSON));
    }

    return node;
}

/* Delete a cJSON structure. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
{
    cJSON *next = NULL;
    while (item != NULL)
    {
        next = item->next;
        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
        {
            cJSON_Delete(item->child);
        }
        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
        {
            global_hooks.deallocate(item->valuestring);
            item->valuestring = NULL;
        }
        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
        {
            global_hooks.deallocate(item->string);
            item->string = NULL;
        }
        global_hooks.deallocate(item);
        item = next;
    }
}

/* get the decimal point character of the current locale */
static unsigned char get_decimal_point(void)
{
#ifdef ENABLE_LOCALES
    struct lconv *lconv = localeconv();
    return (unsigned char) lconv->decimal_point[0];
#else
    return '.';
#endif
}

typedef struct
{
    const unsigned char *content;
    size_t length;
    size_t offset;
    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
    internal_hooks hooks;
} parse_buffer;

/* check if the given size is left to read in a given parse buffer (starting with 1) */
#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
/* check if the buffer can be accessed at the given index (starting with 0) */
#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
/* get a pointer to the buffer at the position */
#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)

/* Parse the input text to generate a number, and populate the result into item. */
static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
{
    double number = 0;
    unsigned char *after_end = NULL;
    unsigned char *number_c_string;
    unsigned char decimal_point = get_decimal_point();
    size_t i = 0;
    size_t number_string_length = 0;
    cJSON_bool has_decimal_point = false;

    if ((input_buffer == NULL) || (input_buffer->content == NULL))
    {
        return false;
    }

    /* copy the number into a temporary buffer and replace '.' with the decimal point
     * of the current locale (for strtod)
     * This also takes care of '\0' not necessarily being available for marking the end of the input */
    for (i = 0; can_access_at_index(input_buffer, i); i++)
    {
        switch (buffer_at_offset(input_buffer)[i])
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case '+':
            case '-':
            case 'e':
            case 'E':
                number_string_length++;
                break;

            case '.':
                number_string_length++;
                has_decimal_point = true;
                break;

            default:
                goto loop_end;
        }
    }
loop_end:
    /* malloc for temporary buffer, add 1 for '\0' */
    number_c_string = (unsigned char *) input_buffer->hooks.allocate(number_string_length + 1);
    if (number_c_string == NULL)
    {
        return false; /* allocation failure */
    }

    memcpy(number_c_string, buffer_at_offset(input_buffer), number_string_length);
    number_c_string[number_string_length] = '\0';

    if (has_decimal_point)
    {
        for (i = 0; i < number_string_length; i++)
        {
            if (number_c_string[i] == '.')
            {
                /* replace '.' with the decimal point of the current locale (for strtod) */
                number_c_string[i] = decimal_point;
            }
        }
    }

    number = strtod((const char*)number_c_string, (char**)&after_end);
    if (number_c_string == after_end)
    {
        /* free the temporary buffer */
        input_buffer->hooks.deallocate(number_c_string);
        return false; /* parse_error */
    }

    item->valuedouble = number;

    /* use saturation in case of overflow */
    if (number >= INT_MAX)
    {
        item->valueint = INT_MAX;
    }
    else if (number <= (double)INT_MIN)
    {
        item->valueint = INT_MIN;
    }
    else
    {
        item->valueint = (int)number;
    }

    item->type = cJSON_Number;

    input_buffer->offset += (size_t)(after_end - number_c_string);
    /* free the temporary buffer */
    input_buffer->hooks.deallocate(number_c_string);
    return true;
}

/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
{
    if (number >= INT_MAX)
    {
        object->valueint = INT_MAX;
    }
    else if (number <= (double)INT_MIN)
    {
        object->valueint = INT_MIN;
    }
    else
    {
        object->valueint = (int)number;
    }

    return object->valuedouble = number;
}

/* Note: when passing a NULL valuestring, cJSON_SetValuestring treats this as an error and return NULL */
CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring)
{
    char *copy = NULL;
    size_t v1_len;
    size_t v2_len;
    /* if object's type is not cJSON_String or is cJSON_IsReference, it should not set valuestring */
    if ((object == NULL) || !(object->type & cJSON_String) || (object->type & cJSON_IsReference))
    {
        return NULL;
    }
    /* return NULL if the object is corrupted or valuestring is NULL */
    if (object->valuestring == NULL || valuestring == NULL)
    {
        return NULL;
    }

    v1_len = strlen(valuestring);
    v2_len = strlen(object->valuestring);

    if (v1_len <= v2_len)
    {
        /* strcpy does not handle overlapping string: [X1, X2] [Y1, Y2] => X2 < Y1 or Y2 < X1 */
        if (!( valuestring + v1_len < object->valuestring || object->valuestring + v2_len < valuestring ))
        {
            return NULL;
        }
        strcpy(object->valuestring, valuestring);
        return object->valuestring;
    }
    copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);
    if (copy == NULL)
    {
        return NULL;
    }
    if (object->valuestring != NULL)
    {
        cJSON_free(object->valuestring);
    }
    object->valuestring = copy;

    return copy;
}

typedef struct
{
    unsigned char *buffer;
    size_t length;
    size_t offset;
    size_t depth; /* current nesting depth (for formatted printing) */
    cJSON_bool noalloc;
    cJSON_bool format; /* is this print a formatted print */
    internal_hooks hooks;
} printbuffer;

/* realloc printbuffer if necessary to have at least "needed" bytes more */
static unsigned char* ensure(printbuffer * const p, size_t needed)
{
    unsigned char *newbuffer = NULL;
    size_t newsize = 0;

    if ((p == NULL) || (p->buffer == NULL))
    {
        return NULL;
    }

    if ((p->length > 0) && (p->offset >= p->length))
    {
        /* make sure that offset is valid */
        return NULL;
    }

    if (needed > INT_MAX)
    {
        /* sizes bigger than INT_MAX are currently not supported */
        return NULL;
    }

    needed += p->offset + 1;
    if (needed <= p->length)
    {
        return p->buffer + p->offset;
    }

    if (p->noalloc) {
        return NULL;
    }

    /* calculate new buffer size */
    if (needed > (INT_MAX / 2))
    {
        /* overflow of int, use INT_MAX if possible */
        if (needed <= INT_MAX)
        {
            newsize = INT_MAX;
        }
        else
        {
            return NULL;
        }
    }
    else
    {
        newsize = needed * 2;
    }

    if (p->hooks.reallocate != NULL)
    {
        /* reallocate with realloc if available */
        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
        if (newbuffer == NULL)
        {
            p->hooks.deallocate(p->buffer);
            p->length = 0;
            p->buffer = NULL;

            return NULL;
        }
    }
    else
    {
        /* otherwise reallocate manually */
        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
        if (!newbuffer)
        {
            p->hooks.deallocate(p->buffer);
            p->length = 0;
            p->buffer = NULL;

            return NULL;
        }

        memcpy(newbuffer, p->buffer, p->offset + 1);
        p->hooks.deallocate(p->buffer);
    }
    p->length = newsize;
    p->buffer = newbuffer;

    return newbuffer + p->offset;
}

/* calculate the new length of the string in a printbuffer and update the offset */
static void update_offset(printbuffer * const buffer)
{
    const unsigned char *buffer_pointer = NULL;
    if ((buffer == NULL) || (buffer->buffer == NULL))
    {
        return;
    }
    buffer_pointer = buffer->buffer + buffer->offset;

    buffer->offset += strlen((const char*)buffer_pointer);
}

/* securely comparison of floating-point variables */
static cJSON_bool compare_double(double a, double b)
{
    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);
    return (fabs(a - b) <= maxVal * DBL_EPSILON);
}

/* Render the number nicely from the given item into a string. */
static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
{
    unsigned char *output_pointer = NULL;
    double d = item->valuedouble;
    int length = 0;
    size_t i = 0;
    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
    unsigned char decimal_point = get_decimal_point();
    double test = 0.0;

    if (output_buffer == NULL)
    {
        return false;
    }

    /* This checks for NaN and Infinity */
    if (isnan(d) || isinf(d))
    {
        length = sprintf((char*)number_buffer, "null");
    }
    else if(d == (double)item->valueint)
    {
        length = sprintf((char*)number_buffer, "%d", item->valueint);
    }
    else
    {
        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
        length = sprintf((char*)number_buffer, "%1.15g", d);

        /* Check whether the original double can be recovered */
        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d))
        {
            /* If not, print with 17 decimal places of precision */
            length = sprintf((char*)number_buffer, "%1.17g", d);
        }
    }

    /* sprintf failed or buffer overrun occurred */
    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
    {
        return false;
    }

    /* reserve appropriate space in the output */
    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
    if (output_pointer == NULL)
    {
        return false;
    }

    /* copy the printed number to the output and replace locale
     * dependent decimal point with '.' */
    for (i = 0; i < ((size_t)length); i++)
    {
        if (number_buffer[i] == decimal_point)
        {
            output_pointer[i] = '.';
            continue;
        }

        output_pointer[i] = number_buffer[i];
    }
    output_pointer[i] = '\0';

    output_buffer->offset += (size_t)length;

    return true;
}

/* parse 4 digit hexadecimal number */
static unsigned parse_hex4(const unsigned char * const input)
{
    unsigned int h = 0;
    size_t i = 0;

    for (i = 0; i < 4; i++)
    {
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
        {
            h += (unsigned int) 10 + input[i] - 'A';
        }
        else if ((input[i] >= 'a') && (input[i] <= 'f'))
        {
            h += (unsigned int) 10 + input[i] - 'a';
        }
        else /* invalid */
        {
            return 0;
        }

        if (i < 3)
        {
            /* shift left to make place for the next nibble */
            h = h << 4;
        }
    }

    return h;
}

/* converts a UTF-16 literal to UTF-8
 * A literal can be one or two sequences of the form \uXXXX */
static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
{
    long unsigned int codepoint = 0;
    unsigned int first_code = 0;
    const unsigned char *first_sequence = input_pointer;
    unsigned char utf8_length = 0;
    unsigned char utf8_position = 0;
    unsigned char sequence_length = 0;
    unsigned char first_byte_mark = 0;

    if ((input_end - first_sequence) < 6)
    {
        /* input ends unexpectedly */
        goto fail;
    }

    /* get the first utf16 sequence */
    first_code = parse_hex4(first_sequence + 2);

    /* check that the code is valid */
    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
    {
        goto fail;
    }

    /* UTF16 surrogate pair */
    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
    {
        const unsigned char *second_sequence = first_sequence + 6;
        unsigned int second_code = 0;
        sequence_length = 12; /* \uXXXX\uXXXX */

        if ((input_end - second_sequence) < 6)
        {
            /* input ends unexpectedly */
            goto fail;
        }

        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
        {
            /* missing second half of the surrogate pair */
            goto fail;
        }

        /* get the second utf16 sequence */
        second_code = parse_hex4(second_sequence + 2);
        /* check that the code is valid */
        if ((second_code < 0xDC00) || (second_code > 0xDFFF))
        {
            /* invalid second half of the surrogate pair */
            goto fail;
        }


        /* calculate the unicode codepoint from the surrogate pair */
        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
    }
    else
    {
        sequence_length = 6; /* \uXXXX */
        codepoint = first_code;
    }

    /* encode as UTF-8
     * takes at maximum 4 bytes to encode:
     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    if (codepoint < 0x80)
    {
        /* normal ascii, encoding 0xxxxxxx */
        utf8_length = 1;
    }
    else if (codepoint < 0x800)
    {
        /* two bytes, encoding 110xxxxx 10xxxxxx */
        utf8_length = 2;
        first_byte_mark = 0xC0; /* 11000000 */
    }
    else if (codepoint < 0x10000)
    {
        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        utf8_length = 3;
        first_byte_mark = 0xE0; /* 11100000 */
    }
    else if (codepoint <= 0x10FFFF)
    {
        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
        utf8_length = 4;
        first_byte_mark = 0xF0; /* 11110000 */
    }
    else
    {
        /* invalid unicode codepoint */
        goto fail;
    }

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
    {
        /* 10xxxxxx */
        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
        codepoint >>= 6;
    }
    /* encode first byte */
    if (utf8_length > 1)
    {
        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
    }
    else
    {
        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
    }

    *output_pointer += utf8_length;

    return sequence_length;

fail:
    return 0;
}

/* Parse the input text into an unescaped cinput, and populate item. */
static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
{
    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
    unsigned char *output_pointer = NULL;
    unsigned char *output = NULL;

    /* not a string */
    if (buffer_at_offset(input_buffer)[0] != '\"')
    {
        goto fail;
    }

    {
        /* calculate approximate size of the output (overestimate) */
        size_t allocation_length = 0;
        size_t skipped_bytes = 0;
        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
        {
            /* is escape sequence */
            if (input_end[0] == '\\')
            {
                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
                {
                    /* prevent buffer overflow when last input character is a backslash */
                    goto fail;
                }
                skipped_bytes++;
                input_end++;
            }
            input_end++;
        }
        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
        {
            goto fail; /* string ended unexpectedly */
        }

        /* This is at most how much we need for the output */
        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
        if (output == NULL)
        {
            goto fail; /* allocation failure */
        }
    }

    output_pointer = output;
    /* loop through the string literal */
    while (input_pointer < input_end)
    {
        if (*input_pointer != '\\')
        {
            *output_pointer++ = *input_pointer++;
        }
        /* escape sequence */
        else
        {
            unsigned char sequence_length = 2;
            if ((input_end - input_pointer) < 1)
            {
                goto fail;
            }

            switch (input_pointer[1])
            {
                case 'b':
                    *output_pointer++ = '\b';
                    break;
                case 'f':
                    *output_pointer++ = '\f';
                    break;
                case 'n':
                    *output_pointer++ = '\n';
                    break;
                case 'r':
                    *output_pointer++ = '\r';
                    break;
                case 't':
                    *output_pointer++ = '\t';
                    break;
                case '\"':
                case '\\':
                case '/':
                    *output_pointer++ = input_pointer[1];
                    break;

                /* UTF-16 literal */
                case 'u':
                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
                    if (sequence_length == 0)
                    {
                        /* failed to convert UTF16-literal to UTF-8 */
                        goto fail;
                    }
                    break;

                default:
                    goto fail;
            }
            input_pointer += sequence_length;
        }
    }

    /* zero terminate the output */
    *output_pointer = '\0';

    item->type = cJSON_String;
    item->valuestring = (char*)output;

    input_buffer->offset = (size_t) (input_end - input_buffer->content);
    input_buffer->offset++;

    return true;

fail:
    if (output != NULL)
    {
        input_buffer->hooks.deallocate(output);
        output = NULL;
    }

    if (input_pointer != NULL)
    {
        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
    }

    return false;
}

/* Render the cstring provided to an escaped version that can be printed. */
static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
{
    const unsigned char *input_pointer = NULL;
    unsigned char *output = NULL;
    unsigned char *output_pointer = NULL;
    size_t output_length = 0;
    /* numbers of additional characters needed for escaping */
    size_t escape_characters = 0;

    if (output_buffer == NULL)
    {
        return false;
    }

    /* empty string */
    if (input == NULL)
    {
        output = ensure(output_buffer, sizeof("\"\""));
        if (output == NULL)
        {
            return false;
        }
        strcpy((char*)output, "\"\"");

        return true;
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
    {
        switch (*input_pointer)
        {
            case '\"':
            case '\\':
            case '\b':
            case '\f':
            case '\n':
            case '\r':
            case '\t':
                /* one character escape sequence */
                escape_characters++;
                break;
            default:
                if (*input_pointer < 32)
                {
                    /* UTF-16 escape sequence uXXXX */
                    escape_characters += 5;
                }
                break;
        }
    }
    output_length = (size_t)(input_pointer - input) + escape_characters;

    output = ensure(output_buffer, output_length + sizeof("\"\""));
    if (output == NULL)
    {
        return false;
    }

    /* no characters have to be escaped */
    if (escape_characters == 0)
    {
        output[0] = '\"';
        memcpy(output + 1, input, output_length);
        output[output_length + 1] = '\"';
        output[output_length + 2] = '\0';

        return true;
    }

    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
    {
        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
        {
            /* normal character, copy */
            *output_pointer = *input_pointer;
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
            switch (*input_pointer)
            {
                case '\\':
                    *output_pointer = '\\';
                    break;
                case '\"':
                    *output_pointer = '\"';
                    break;
                case '\b':
                    *output_pointer = 'b';
                    break;
                case '\f':
                    *output_pointer = 'f';
                    break;
                case '\n':
                    *output_pointer = 'n';
                    break;
                case '\r':
                    *output_pointer = 'r';
                    break;
                case '\t':
                    *output_pointer = 't';
                    break;
                default:
                    /* escape and print as unicode codepoint */
                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
                    output_pointer += 4;
                    break;
            }
        }
    }
    output[output_length + 1] = '\"';
    output[output_length + 2] = '\0';

    return true;
}

/* Invoke print_string_ptr (which is useful) on an item. */
static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
{
    return print_string_ptr((unsigned char*)item->valuestring, p);
}

/* Predeclare these prototypes. */
static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);

/* Utility to jump whitespace and cr/lf */
static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
{
    if ((buffer == NULL) || (buffer->content == NULL))
    {
        return NULL;
    }

    if (cannot_access_at_index(buffer, 0))
    {
        return buffer;
    }

    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
    {
       buffer->offset++;
    }

    if (buffer->offset == buffer->length)
    {
        buffer->offset--;
    }

    return buffer;
}

/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
{
    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
    {
        return NULL;
    }

    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
    {
        buffer->offset += 3;
    }

    return buffer;
}

CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
{
    size_t buffer_length;

    if (NULL == value)
    {
        return NULL;
    }

    /* Adding null character size due to require_null_terminated. */
    buffer_length = strlen(value) + sizeof("");

    return cJSON_ParseWithLengthOpts(value, buffer_length, return_parse_end, require_null_terminated);
}

/* Parse an object - create a new root, and populate. */
CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)
{
    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
    cJSON *item = NULL;

    /* reset error position */
    global_error.json = NULL;
    global_error.position = 0;

    if (value == NULL || 0 == buffer_length)
    {
        goto fail;
    }

    buffer.content = (const unsigned char*)value;
    buffer.length = buffer_length;
    buffer.offset = 0;
    buffer.hooks = global_hooks;

    item = cJSON_New_Item(&global_hooks);
    if (item == NULL) /* memory fail */
    {
        goto fail;
    }

    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
    {
        /* parse failure. ep is set. */
        goto fail;
    }

    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
    if (require_null_terminated)
    {
        buffer_skip_whitespace(&buffer);
        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
        {
            goto fail;
        }
    }
    if (return_parse_end)
    {
        *return_parse_end = (const char*)buffer_at_offset(&buffer);
    }

    return item;

fail:
    if (item != NULL)
    {
        cJSON_Delete(item);
    }

    if (value != NULL)
    {
        error local_error;
        local_error.json = (const unsigned char*)value;
        local_error.position = 0;

        if (buffer.offset < buffer.length)
        {
            local_error.position = buffer.offset;
        }
        else if (buffer.length > 0)
        {
            local_error.position = buffer.length - 1;
        }

        if (return_parse_end != NULL)
        {
            *return_parse_end = (const char*)local_error.json + local_error.position;
        }

        global_error = local_error;
    }

    return NULL;
}

/* Default options for cJSON_Parse */
CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
{
    return cJSON_ParseWithOpts(value, 0, 0);
}

CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length)
{
    return cJSON_ParseWithLengthOpts(value, buffer_length, 0, 0);
}

#define cjson_min(a, b) (((a) < (b)) ? (a) : (b))

static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
{
    static const size_t default_buffer_size = 256;
    printbuffer buffer[1];
    unsigned char *printed = NULL;

    memset(buffer, 0, sizeof(buffer));

    /* create buffer */
    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
    buffer->length = default_buffer_size;
    buffer->format = format;
    buffer->hooks = *hooks;
    if (buffer->buffer == NULL)
    {
        goto fail;
    }

    /* print the value */
    if (!print_value(item, buffer))
    {
        goto fail;
    }
    update_offset(buffer);

    /* check if reallocate is available */
    if (hooks->reallocate != NULL)
    {
        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
        if (printed == NULL) {
            goto fail;
        }
        buffer->buffer = NULL;
    }
    else /* otherwise copy the JSON over to a new buffer */
    {
        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
        if (printed == NULL)
        {
            goto fail;
        }
        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
        printed[buffer->offset] = '\0'; /* just to be sure */

        /* free the buffer */
        hooks->deallocate(buffer->buffer);
        buffer->buffer = NULL;
    }

    return printed;

fail:
    if (buffer->buffer != NULL)
    {
        hooks->deallocate(buffer->buffer);
        buffer->buffer = NULL;
    }

    if (printed != NULL)
    {
        hooks->deallocate(printed);
        printed = NULL;
    }

    return NULL;
}

/* Render a cJSON item/entity/structure to text. */
CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
{
    return (char*)print(item, true, &global_hooks);
}

CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
{
    return (char*)print(item, false, &global_hooks);
}

CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
{
    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };

    if (prebuffer < 0)
    {
        return NULL;
    }

    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
    if (!p.buffer)
    {
        return NULL;
    }

    p.length = (size_t)prebuffer;
    p.offset = 0;
    p.noalloc = false;
    p.format = fmt;
    p.hooks = global_hooks;

    if (!print_value(item, &p))
    {
        global_hooks.deallocate(p.buffer);
        p.buffer = NULL;
        return NULL;
    }

    return (char*)p.buffer;
}

CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
{
    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };

    if ((length < 0) || (buffer == NULL))
    {
        return false;
    }

    p.buffer = (unsigned char*)buffer;
    p.length = (size_t)length;
    p.offset = 0;
    p.noalloc = true;
    p.format = format;
    p.hooks = global_hooks;

    return print_value(item, &p);
}

/* Parser core - when encountering text, process appropriately. */
static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
{
    if ((input_buffer == NULL) || (input_buffer->content == NULL))
    {
        return false; /* no input */
    }

    /* parse the different types of values */
    /* null */
    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
    {
        item->type = cJSON_NULL;
        input_buffer->offset += 4;
        return true;
    }
    /* false */
    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
    {
        item->type = cJSON_False;
        input_buffer->offset += 5;
        return true;
    }
    /* true */
    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
    {
        item->type = cJSON_True;
        item->valueint = 1;
        input_buffer->offset += 4;
        return true;
    }
    /* string */
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
    {
        return parse_string(item, input_buffer);
    }
    /* number */
    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
    {
        return parse_number(item, input_buffer);
    }
    /* array */
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
    {
        return parse_array(item, input_buffer);
    }
    /* object */
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
    {
        return parse_object(item, input_buffer);
    }

    return false;
}

/* Render a value to text. */
static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
{
    unsigned char *output = NULL;

    if ((item == NULL) || (output_buffer == NULL))
    {
        return false;
    }

    switch ((item->type) & 0xFF)
    {
        case cJSON_NULL:
            output = ensure(output_buffer, 5);
            if (output == NULL)
            {
                return false;
            }
            strcpy((char*)output, "null");
            return true;

        case cJSON_False:
            output = ensure(output_buffer, 6);
            if (output == NULL)
            {
                return false;
            }
            strcpy((char*)output, "false");
            return true;

        case cJSON_True:
            output = ensure(output_buffer, 5);
            if (output == NULL)
            {
                return false;
            }
            strcpy((char*)output, "true");
            return true;

        case cJSON_Number:
            return print_number(item, output_buffer);

        case cJSON_Raw:
        {
            size_t raw_length = 0;
            if (item->valuestring == NULL)
            {
                return false;
            }

            raw_length = strlen(item->valuestring) + sizeof("");
            output = ensure(output_buffer, raw_length);
            if (output == NULL)
            {
                return false;
            }
            memcpy(output, item->valuestring, raw_length);
            return true;
        }

        case cJSON_String:
            return print_string(item, output_buffer);

        case cJSON_Array:
            return print_array(item, output_buffer);

        case cJSON_Object:
            return print_object(item, output_buffer);

        default:
            return false;
    }
}

/* Build an array from input text. */
static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* head of the linked list */
    cJSON *current_item = NULL;

    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
    {
        return false; /* to deeply nested */
    }
    input_buffer->depth++;

    if (buffer_at_offset(input_buffer)[0] != '[')
    {
        /* not an array */
        goto fail;
    }

    input_buffer->offset++;
    buffer_skip_whitespace(input_buffer);
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
    {
        /* empty array */
        goto success;
    }

    /* check if we skipped to the end of the buffer */
    if (cannot_access_at_index(input_buffer, 0))
    {
        input_buffer->offset--;
        goto fail;
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
    /* loop through the comma separated array elements */
    do
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
        if (new_item == NULL)
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
        {
            /* start the linked list */
            current_item = head = new_item;
        }
        else
        {
            /* add to the end and advance */
            current_item->next = new_item;
            new_item->prev = current_item;
            current_item = new_item;
        }

        /* parse next value */
        input_buffer->offset++;
        buffer_skip_whitespace(input_buffer);
        if (!parse_value(current_item, input_buffer))
        {
            goto fail; /* failed to parse value */
        }
        buffer_skip_whitespace(input_buffer);
    }
    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));

    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
    {
        goto fail; /* expected end of array */
    }

success:
    input_buffer->depth--;

    if (head != NULL) {
        head->prev = current_item;
    }

    item->type = cJSON_Array;
    item->child = head;

    input_buffer->offset++;

    return true;

fail:
    if (head != NULL)
    {
        cJSON_Delete(head);
    }

    return false;
}

/* Render an array to text */
static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
{
    unsigned char *output_pointer = NULL;
    size_t length = 0;
    cJSON *current_element = item->child;

    if (output_buffer == NULL)
    {
        return false;
    }

    /* Compose the output array. */
    /* opening square bracket */
    output_pointer = ensure(output_buffer, 1);
    if (output_pointer == NULL)
    {
        return false;
    }

    *output_pointer = '[';
    output_buffer->offset++;
    output_buffer->depth++;

    while (current_element != NULL)
    {
        if (!print_value(current_element, output_buffer))
        {
            return false;
        }
        update_offset(output_buffer);
        if (current_element->next)
        {
            length = (size_t) (output_buffer->format ? 2 : 1);
            output_pointer = ensure(output_buffer, length + 1);
            if (output_pointer == NULL)
            {
                return false;
            }
            *output_pointer++ = ',';
            if(output_buffer->format)
            {
                *output_pointer++ = ' ';
            }
            *output_pointer = '\0';
            output_buffer->offset += length;
        }
        current_element = current_element->next;
    }

    output_pointer = ensure(output_buffer, 2);
    if (output_pointer == NULL)
    {
        return false;
    }
    *output_pointer++ = ']';
    *output_pointer = '\0';
    output_buffer->depth--;

    return true;
}

/* Build an object from the text. */
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* linked list head */
    cJSON *current_item = NULL;

    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
    {
        return false; /* to deeply nested */
    }
    input_buffer->depth++;

    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
    {
        goto fail; /* not an object */
    }

    input_buffer->offset++;
    buffer_skip_whitespace(input_buffer);
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
    {
        goto success; /* empty object */
    }

    /* check if we skipped to the end of the buffer */
    if (cannot_access_at_index(input_buffer, 0))
    {
        input_buffer->offset--;
        goto fail;
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
    /* loop through the comma separated array elements */
    do
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
        if (new_item == NULL)
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
        {
            /* start the linked list */
            current_item = head = new_item;
        }
        else
        {
            /* add to the end and advance */
            current_item->next = new_item;
            new_item->prev = current_item;
            current_item = new_item;
        }

        if (cannot_access_at_index(input_buffer, 1))
        {
            goto fail; /* nothing comes after the comma */
        }

        /* parse the name of the child */
        input_buffer->offset++;
        buffer_skip_whitespace(input_buffer);
        if (!parse_string(current_item, input_buffer))
        {
            goto fail; /* failed to parse name */
        }
        buffer_skip_whitespace(input_buffer);

        /* swap valuestring and string, because we parsed the name */
        current_item->string = current_item->valuestring;
        current_item->valuestring = NULL;

        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
        {
            goto fail; /* invalid object */
        }

        /* parse the value */
        input_buffer->offset++;
        buffer_skip_whitespace(input_buffer);
        if (!parse_value(current_item, input_buffer))
        {
            goto fail; /* failed to parse value */
        }
        buffer_skip_whitespace(input_buffer);
    }
    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));

    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
    {
        goto fail; /* expected end of object */
    }

success:
    input_buffer->depth--;

    if (head != NULL) {
        head->prev = current_item;
    }

    item->type = cJSON_Object;
    item->child = head;

    input_buffer->offset++;
    return true;

fail:
    if (head != NULL)
    {
        cJSON_Delete(head);
    }

    return false;
}

/* Render an object to text. */
static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
{
    unsigned char *output_pointer = NULL;
    size_t length = 0;
    cJSON *current_item = item->child;

    if (output_buffer == NULL)
    {
        return false;
    }

    /* Compose the output: */
    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
    output_pointer = ensure(output_buffer, length + 1);
    if (output_pointer == NULL)
    {
        return false;
    }

    *output_pointer++ = '{';
    output_buffer->depth++;
    if (output_buffer->format)
    {
        *output_pointer++ = '\n';
    }
    output_buffer->offset += length;

    while (current_item)
    {
        if (output_buffer->format)
        {
            size_t i;
            output_pointer = ensure(output_buffer, output_buffer->depth);
            if (output_pointer == NULL)
            {
                return false;
            }
            for (i = 0; i < output_buffer->depth; i++)
            {
                *output_pointer++ = '\t';
            }
            output_buffer->offset += output_buffer->depth;
        }

        /* print key */
        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
        {
            return false;
        }
        update_offset(output_buffer);

        length = (size_t) (output_buffer->format ? 2 : 1);
        output_pointer = ensure(output_buffer, length);
        if (output_pointer == NULL)
        {
            return false;
        }
        *output_pointer++ = ':';
        if (output_buffer->format)
        {
            *output_pointer++ = '\t';
        }
        output_buffer->offset += length;

        /* print value */
        if (!print_value(current_item, output_buffer))
        {
            return false;
        }
        update_offset(output_buffer);

        /* print comma if not last */
        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
        output_pointer = ensure(output_buffer, length + 1);
        if (output_pointer == NULL)
        {
            return false;
        }
        if (current_item->next)
        {
            *output_pointer++ = ',';
        }

        if (output_buffer->format)
        {
            *output_pointer++ = '\n';
        }
        *output_pointer = '\0';
        output_buffer->offset += length;

        current_item = current_item->next;
    }

    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
    if (output_pointer == NULL)
    {
        return false;
    }
    if (output_buffer->format)
    {
        size_t i;
        for (i = 0; i < (output_buffer->depth - 1); i++)
        {
            *output_pointer++ = '\t';
        }
    }
    *output_pointer++ = '}';
    *output_pointer = '\0';
    output_buffer->depth--;

    return true;
}

/* Get Array size/item / object item. */
CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
{
    cJSON *child = NULL;
    size_t size = 0;

    if (array == NULL)
    {
        return 0;
    }

    child = array->child;

    while(child != NULL)
    {
        size++;
        child = child->next;
    }

    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */

    return (int)size;
}

static cJSON* get_array_item(const cJSON *array, size_t index)
{
    cJSON *current_child = NULL;

    if (array == NULL)
    {
        return NULL;
    }

    current_child = array->child;
    while ((current_child != NULL) && (index > 0))
    {
        index--;
        current_child = current_child->next;
    }

    return current_child;
}

CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
{
    if (index < 0)
    {
        return NULL;
    }

    return get_array_item(array, (size_t)index);
}

static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    }

    current_element = object->child;
    if (case_sensitive)
    {
        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
        {
            current_element = current_element->next;
        }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
        }
    }

    if ((current_element == NULL) || (current_element->string == NULL)) {
        return NULL;
    }

    return current_element;
}

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
{
    return get_object_item(object, string, false);
}

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
{
    return get_object_item(object, string, true);
}

CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
{
    return cJSON_GetObjectItem(object, string) ? 1 : 0;
}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev, cJSON *item)
{
    prev->next = item;
    item->prev = prev;
}

/* Utility for handling references. */
static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
{
    cJSON *reference = NULL;
    if (item == NULL)
    {
        return NULL;
    }

    reference = cJSON_New_Item(hooks);
    if (reference == NULL)
    {
        return NULL;
    }

    memcpy(reference, item, sizeof(cJSON));
    reference->string = NULL;
    reference->type |= cJSON_IsReference;
    reference->next = reference->prev = NULL;
    return reference;
}

static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
{
    cJSON *child = NULL;

    if ((item == NULL) || (array == NULL) || (array == item))
    {
        return false;
    }

    child = array->child;
    /*
     * To find the last item in array quickly, we use prev in array
     */
    if (child == NULL)
    {
        /* list is empty, start new one */
        array->child = item;
        item->prev = item;
        item->next = NULL;
    }
    else
    {
        /* append to the end */
        if (child->prev)
        {
            suffix_object(child->prev, item);
            array->child->prev = item;
        }
    }

    return true;
}

/* Add item to array/object. */
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item)
{
    return add_item_to_array(array, item);
}

#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
    #pragma GCC diagnostic push
#endif
#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif
/* helper function to cast away const */
static void* cast_away_const(const void* string)
{
    return (void*)string;
}
#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
    #pragma GCC diagnostic pop
#endif


static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
{
    char *new_key = NULL;
    int new_type = cJSON_Invalid;

    if ((object == NULL) || (string == NULL) || (item == NULL) || (object == item))
    {
        return false;
    }

    if (constant_key)
    {
        new_key = (char*)cast_away_const(string);
        new_type = item->type | cJSON_StringIsConst;
    }
    else
    {
        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
        if (new_key == NULL)
        {
            return false;
        }

        new_type = item->type & ~cJSON_StringIsConst;
    }

    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
    {
        hooks->deallocate(item->string);
    }

    item->string = new_key;
    item->type = new_type;

    return add_item_to_array(object, item);
}

CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
{
    return add_item_to_object(object, string, item, &global_hooks, false);
}

/* Add an item to an object with constant string as key */
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
{
    return add_item_to_object(object, string, item, &global_hooks, true);
}

CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
{
    if (array == NULL)
    {
        return false;
    }

    return add_item_to_array(array, create_reference(item, &global_hooks));
}

CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
{
    if ((object == NULL) || (string == NULL))
    {
        return false;
    }

    return add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
}

CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
{
    cJSON *null = cJSON_CreateNull();
    if (add_item_to_object(object, name, null, &global_hooks, false))
    {
        return null;
    }

    cJSON_Delete(null);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
{
    cJSON *true_item = cJSON_CreateTrue();
    if (add_item_to_object(object, name, true_item, &global_hooks, false))
    {
        return true_item;
    }

    cJSON_Delete(true_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
{
    cJSON *false_item = cJSON_CreateFalse();
    if (add_item_to_object(object, name, false_item, &global_hooks, false))
    {
        return false_item;
    }

    cJSON_Delete(false_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
{
    cJSON *bool_item = cJSON_CreateBool(boolean);
    if (add_item_to_object(object, name, bool_item, &global_hooks, false))
    {
        return bool_item;
    }

    cJSON_Delete(bool_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
{
    cJSON *number_item = cJSON_CreateNumber(number);
    if (add_item_to_object(object, name, number_item, &global_hooks, false))
    {
        return number_item;
    }

    cJSON_Delete(number_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
{
    cJSON *string_item = cJSON_CreateString(string);
    if (add_item_to_object(object, name, string_item, &global_hooks, false))
    {
        return string_item;
    }

    cJSON_Delete(string_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
{
    cJSON *raw_item = cJSON_CreateRaw(raw);
    if (add_item_to_object(object, name, raw_item, &global_hooks, false))
    {
        return raw_item;
    }

    cJSON_Delete(raw_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
{
    cJSON *object_item = cJSON_CreateObject();
    if (add_item_to_object(object, name, object_item, &global_hooks, false))
    {
        return object_item;
    }

    cJSON_Delete(object_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
{
    cJSON *array = cJSON_CreateArray();
    if (add_item_to_object(object, name, array, &global_hooks, false))
    {
        return array;
    }

    cJSON_Delete(array);
    return NULL;
}

CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
{
    if ((parent == NULL) || (item == NULL) || (item != parent->child && item->prev == NULL))
    {
        return NULL;
    }

    if (item != parent->child)
    {
        /* not the first element */
        item->prev->next = item->next;
    }
    if (item->next != NULL)
    {
        /* not the last element */
        item->next->prev = item->prev;
    }

    if (item == parent->child)
    {
        /* first element */
        parent->child = item->next;
    }
    else if (item->next == NULL)
    {
        /* last element */
        parent->child->prev = item->prev;
    }

    /* make sure the detached item doesn't point anywhere anymore */
    item->prev = NULL;
    item->next = NULL;

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
{
    if (which < 0)
    {
        return NULL;
    }

    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
}

CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
{
    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
}

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
{
    cJSON *to_detach = cJSON_GetObjectItem(object, string);

    return cJSON_DetachItemViaPointer(object, to_detach);
}

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
{
    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);

    return cJSON_DetachItemViaPointer(object, to_detach);
}

CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
{
    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
}

CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
{
    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
}

/* Replace array/object items with new ones. */
CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
{
    cJSON *after_inserted = NULL;

    if (which < 0 || newitem == NULL)
    {
        return false;
    }

    after_inserted = get_array_item(array, (size_t)which);
    if (after_inserted == NULL)
    {
        return add_item_to_array(array, newitem);
    }

    if (after_inserted != array->child && after_inserted->prev == NULL) {
        /* return false if after_inserted is a corrupted array item */
        return false;
    }

    newitem->next = after_inserted;
    newitem->prev = after_inserted->prev;
    after_inserted->prev = newitem;
    if (after_inserted == array->child)
    {
        array->child = newitem;
    }
    else
    {
        newitem->prev->next = newitem;
    }
    return true;
}

CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
{
    if ((parent == NULL) || (parent->child == NULL) || (replacement == NULL) || (item == NULL))
    {
        return false;
    }

    if (replacement == item)
    {
        return true;
    }

    replacement->next = item->next;
    replacement->prev = item->prev;

    if (replacement->next != NULL)
    {
        replacement->next->prev = replacement;
    }
    if (parent->child == item)
    {
        if (parent->child->prev == parent->child)
        {
            replacement->prev = replacement;
        }
        parent->child = replacement;
    }
    else
    {   /*
         * To find the last item in array quickly, we use prev in array.
         * We can't modify the last item's next pointer where this item was the parent's child
         */
        if (replacement->prev != NULL)
        {
            replacement->prev->next = replacement;
        }
        if (replacement->next == NULL)
        {
            parent->child->prev = replacement;
        }
    }

    item->next = NULL;
    item->prev = NULL;
    cJSON_Delete(item);

    return true;
}

CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
{
    if (which < 0)
    {
        return false;
    }

    return cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
}

static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
{
    if ((replacement == NULL) || (string == NULL))
    {
        return false;
    }

    /* replace the name in the replacement */
    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
    {
        cJSON_free(replacement->string);
    }
    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
    if (replacement->string == NULL)
    {
        return false;
    }

    replacement->type &= ~cJSON_StringIsConst;

    return cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
}

CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
{
    return replace_item_in_object(object, string, newitem, false);
}

CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
{
    return replace_item_in_object(object, string, newitem, true);
}

/* Create basic types: */
CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_NULL;
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_True;
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_False;
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = boolean ? cJSON_True : cJSON_False;
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_Number;
        item->valuedouble = num;

        /* use saturation in case of overflow */
        if (num >= INT_MAX)
        {
            item->valueint = INT_MAX;
        }
        else if (num <= (double)INT_MIN)
        {
            item->valueint = INT_MIN;
        }
        else
        {
            item->valueint = (int)num;
        }
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_String;
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
        if(!item->valuestring)
        {
            cJSON_Delete(item);
            return NULL;
        }
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if (item != NULL)
    {
        item->type = cJSON_String | cJSON_IsReference;
        item->valuestring = (char*)cast_away_const(string);
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if (item != NULL) {
        item->type = cJSON_Object | cJSON_IsReference;
        item->child = (cJSON*)cast_away_const(child);
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
    cJSON *item = cJSON_New_Item(&global_hooks);
    if (item != NULL) {
        item->type = cJSON_Array | cJSON_IsReference;
        item->child = (cJSON*)cast_away_const(child);
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type = cJSON_Raw;
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
        if(!item->valuestring)
        {
            cJSON_Delete(item);
            return NULL;
        }
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if(item)
    {
        item->type=cJSON_Array;
    }

    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    if (item)
    {
        item->type = cJSON_Object;
    }

    return item;
}

/* Create Arrays: */
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
{
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if ((count < 0) || (numbers == NULL))
    {
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0; a && (i < (size_t)count); i++)
    {
        n = cJSON_CreateNumber(numbers[i]);
        if (!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
        }
        else
        {
            suffix_object(p, n);
        }
        p = n;
    }

    if (a && a->child) {
        a->child->prev = n;
    }

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
{
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if ((count < 0) || (numbers == NULL))
    {
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0; a && (i < (size_t)count); i++)
    {
        n = cJSON_CreateNumber((double)numbers[i]);
        if(!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
        }
        else
        {
            suffix_object(p, n);
        }
        p = n;
    }

    if (a && a->child) {
        a->child->prev = n;
    }

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
{
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if ((count < 0) || (numbers == NULL))
    {
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0; a && (i < (size_t)count); i++)
    {
        n = cJSON_CreateNumber(numbers[i]);
        if(!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
        }
        else
        {
            suffix_object(p, n);
        }
        p = n;
    }

    if (a && a->child) {
        a->child->prev = n;
    }

    return a;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)
{
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if ((count < 0) || (strings == NULL))
    {
        return NULL;
    }

    a = cJSON_CreateArray();

    for (i = 0; a && (i < (size_t)count); i++)
    {
        n = cJSON_CreateString(strings[i]);
        if(!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
        }
        else
        {
            suffix_object(p,n);
        }
        p = n;
    }

    if (a && a->child) {
        a->child->prev = n;
    }

    return a;
}

/* Duplication */
cJSON * cJSON_Duplicate_rec(const cJSON *item, size_t depth, cJSON_bool recurse);

CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
{
    return cJSON_Duplicate_rec(item, 0, recurse );
}

cJSON * cJSON_Duplicate_rec(const cJSON *item, size_t depth, cJSON_bool recurse)
{
    cJSON *newitem = NULL;
    cJSON *child = NULL;
    cJSON *next = NULL;
    cJSON *newchild = NULL;

    /* Bail on bad ptr */
    if (!item)
    {
        goto fail;
    }
    /* Create new item */
    newitem = cJSON_New_Item(&global_hooks);
    if (!newitem)
    {
        goto fail;
    }
    /* Copy over all vars */
    newitem->type = item->type & (~cJSON_IsReference);
    newitem->valueint = item->valueint;
    newitem->valuedouble = item->valuedouble;
    if (item->valuestring)
    {
        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
        if (!newitem->valuestring)
        {
            goto fail;
        }
    }
    if (item->string)
    {
        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
        if (!newitem->string)
        {
            goto fail;
        }
    }
    /* If non-recursive, then we're done! */
    if (!recurse)
    {
        return newitem;
    }
    /* Walk the ->next chain for the child. */
    child = item->child;
    while (child != NULL)
    {
        if(depth >= CJSON_CIRCULAR_LIMIT) {
            goto fail;
        }
        newchild = cJSON_Duplicate_rec(child, depth + 1, true); /* Duplicate (with recurse) each item in the ->next chain */
        if (!newchild)
        {
            goto fail;
        }
        if (next != NULL)
        {
            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
            next->next = newchild;
            newchild->prev = next;
            next = newchild;
        }
        else
        {
            /* Set newitem->child and move to it */
            newitem->child = newchild;
            next = newchild;
        }
        child = child->next;
    }
    if (newitem && newitem->child)
    {
        newitem->child->prev = newchild;
    }

    return newitem;

fail:
    if (newitem != NULL)
    {
        cJSON_Delete(newitem);
    }

    return NULL;
}

static void skip_oneline_comment(char **input)
{
    *input += static_strlen("//");

    for (; (*input)[0] != '\0'; ++(*input))
    {
        if ((*input)[0] == '\n') {
            *input += static_strlen("\n");
            return;
        }
    }
}

static void skip_multiline_comment(char **input)
{
    *input += static_strlen("/*");

    for (; (*input)[0] != '\0'; ++(*input))
    {
        if (((*input)[0] == '*') && ((*input)[1] == '/'))
        {
            *input += static_strlen("*/");
            return;
        }
    }
}

static void minify_string(char **input, char **output) {
    (*output)[0] = (*input)[0];
    *input += static_strlen("\"");
    *output += static_strlen("\"");


    for (; (*input)[0] != '\0'; (void)++(*input), ++(*output)) {
        (*output)[0] = (*input)[0];

        if ((*input)[0] == '\"') {
            (*output)[0] = '\"';
            *input += static_strlen("\"");
            *output += static_strlen("\"");
            return;
        } else if (((*input)[0] == '\\') && ((*input)[1] == '\"')) {
            (*output)[1] = (*input)[1];
            *input += static_strlen("\"");
            *output += static_strlen("\"");
        }
    }
}

CJSON_PUBLIC(void) cJSON_Minify(char *json)
{
    char *into = json;

    if (json == NULL)
    {
        return;
    }

    while (json[0] != '\0')
    {
        switch (json[0])
        {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                json++;
                break;

            case '/':
                if (json[1] == '/')
                {
                    skip_oneline_comment(&json);
                }
                else if (json[1] == '*')
                {
                    skip_multiline_comment(&json);
                } else {
                    json++;
                }
                break;

            case '\"':
                minify_string(&json, (char**)&into);
                break;

            default:
                into[0] = json[0];
                json++;
                into++;
        }
    }

    /* and null-terminate. */
    *into = '\0';
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Invalid;
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_False;
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xff) == cJSON_True;
}


CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & (cJSON_True | cJSON_False)) != 0;
}
CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_NULL;
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Number;
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_String;
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Array;
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Object;
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
{
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Raw;
}

CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
{
    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))
    {
        return false;
    }

    /* check if type is valid */
    switch (a->type & 0xFF)
    {
        case cJSON_False:
        case cJSON_True:
        case cJSON_NULL:
        case cJSON_Number:
        case cJSON_String:
        case cJSON_Raw:
        case cJSON_Array:
        case cJSON_Object:
            break;

        default:
            return false;
    }

    /* identical objects are equal */
    if (a == b)
    {
        return true;
    }

    switch (a->type & 0xFF)
    {
        /* in these cases and equal type is enough */
        case cJSON_False:
        case cJSON_True:
        case cJSON_NULL:
            return true;

        case cJSON_Number:
            if (compare_double(a->valuedouble, b->valuedouble))
            {
                return true;
            }
            return false;

        case cJSON_String:
        case cJSON_Raw:
            if ((a->valuestring == NULL) || (b->valuestring == NULL))
            {
                return false;
            }
            if (strcmp(a->valuestring, b->valuestring) == 0)
            {
                return true;
            }

            return false;

        case cJSON_Array:
        {
            cJSON *a_element = a->child;
            cJSON *b_element = b->child;

            for (; (a_element != NULL) && (b_element != NULL);)
            {
                if (!cJSON_Compare(a_element, b_element, case_sensitive))
                {
                    return false;
                }

                a_element = a_element->next;
                b_element = b_element->next;
            }

            /* one of the arrays is longer than the other */
            if (a_element != b_element) {
                return false;
            }

            return true;
        }

        case cJSON_Object:
        {
            cJSON *a_element = NULL;
            cJSON *b_element = NULL;
            cJSON_ArrayForEach(a_element, a)
            {
                /* TODO This has O(n^2) runtime, which is horrible! */
                b_element = get_object_item(b, a_element->string, case_sensitive);
                if (b_element == NULL)
                {
                    return false;
                }

                if (!cJSON_Compare(a_element, b_element, case_sensitive))
                {
                    return false;
                }
            }

            /* doing this twice, once on a and b to prevent true comparison if a subset of b
             * TODO: Do this the proper way, this is just a fix for now */
            cJSON_ArrayForEach(b_element, b)
            {
                a_element = get_object_item(a, b_element->string, case_sensitive);
                if (a_element == NULL)
                {
                    return false;
                }

                if (!cJSON_Compare(b_element, a_element, case_sensitive))
                {
                    return false;
                }
            }

            return true;
        }

        default:
            return false;
    }
}

CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
{
    return global_hooks.allocate(size);
}

CJSON_PUBLIC(void) cJSON_free(void *object)
{
    global_hooks.deallocate(object);
    object = NULL;
}

```

// FILE: include/cJSON.h
```
/*
  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

#ifndef cJSON__h
#define cJSON__h

#ifdef __cplusplus
extern "C"
{
#endif

#if !defined(__WINDOWS__) && (defined(WIN32) || defined(WIN64) || defined(_MSC_VER) || defined(_WIN32))
#define __WINDOWS__
#endif

#ifdef __WINDOWS__

/* When compiling for windows, we specify a specific calling convention to avoid issues where we are being called from a project with a different default calling convention.  For windows you have 3 define options:

CJSON_HIDE_SYMBOLS - Define this in the case where you don't want to ever dllexport symbols
CJSON_EXPORT_SYMBOLS - Define this on library build when you want to dllexport symbols (default)
CJSON_IMPORT_SYMBOLS - Define this if you want to dllimport symbol

For *nix builds that support visibility attribute, you can define similar behavior by

setting default visibility to hidden by adding
-fvisibility=hidden (for gcc)
or
-xldscope=hidden (for sun cc)
to CFLAGS

then using the CJSON_API_VISIBILITY flag to "export" the same symbols the way CJSON_EXPORT_SYMBOLS does

*/

#define CJSON_CDECL __cdecl
#define CJSON_STDCALL __stdcall

/* export symbols by default, this is necessary for copy pasting the C and header file */
#if !defined(CJSON_HIDE_SYMBOLS) && !defined(CJSON_IMPORT_SYMBOLS) && !defined(CJSON_EXPORT_SYMBOLS)
#define CJSON_EXPORT_SYMBOLS
#endif

#if defined(CJSON_HIDE_SYMBOLS)
#define CJSON_PUBLIC(type)   type CJSON_STDCALL
#elif defined(CJSON_EXPORT_SYMBOLS)
#define CJSON_PUBLIC(type)   __declspec(dllexport) type CJSON_STDCALL
#elif defined(CJSON_IMPORT_SYMBOLS)
#define CJSON_PUBLIC(type)   __declspec(dllimport) type CJSON_STDCALL
#endif
#else /* !__WINDOWS__ */
#define CJSON_CDECL
#define CJSON_STDCALL

#if (defined(__GNUC__) || defined(__SUNPRO_CC) || defined (__SUNPRO_C)) && defined(CJSON_API_VISIBILITY)
#define CJSON_PUBLIC(type)   __attribute__((visibility("default"))) type
#else
#define CJSON_PUBLIC(type) type
#endif
#endif

/* project version */
#define CJSON_VERSION_MAJOR 1
#define CJSON_VERSION_MINOR 7
#define CJSON_VERSION_PATCH 19

#include <stddef.h>

/* cJSON Types: */
#define cJSON_Invalid (0)
#define cJSON_False  (1 << 0)
#define cJSON_True   (1 << 1)
#define cJSON_NULL   (1 << 2)
#define cJSON_Number (1 << 3)
#define cJSON_String (1 << 4)
#define cJSON_Array  (1 << 5)
#define cJSON_Object (1 << 6)
#define cJSON_Raw    (1 << 7) /* raw json */

#define cJSON_IsReference 256
#define cJSON_StringIsConst 512

/* The cJSON structure: */
typedef struct cJSON
{
    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
    struct cJSON *next;
    struct cJSON *prev;
    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
    struct cJSON *child;

    /* The type of the item, as above. */
    int type;

    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */
    char *valuestring;
    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
    int valueint;
    /* The item's number, if type==cJSON_Number */
    double valuedouble;

    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
    char *string;
} cJSON;

typedef struct cJSON_Hooks
{
      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */
      void *(CJSON_CDECL *malloc_fn)(size_t sz);
      void (CJSON_CDECL *free_fn)(void *ptr);
} cJSON_Hooks;

typedef int cJSON_bool;

/* Limits how deeply nested arrays/objects can be before cJSON rejects to parse them.
 * This is to prevent stack overflows. */
#ifndef CJSON_NESTING_LIMIT
#define CJSON_NESTING_LIMIT 1000
#endif

/* Limits the length of circular references can be before cJSON rejects to parse them.
 * This is to prevent stack overflows. */
#ifndef CJSON_CIRCULAR_LIMIT
#define CJSON_CIRCULAR_LIMIT 10000
#endif

/* returns the version of cJSON as a string */
CJSON_PUBLIC(const char*) cJSON_Version(void);

/* Supply malloc, realloc and free functions to cJSON */
CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);

/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */
/* Supply a block of JSON, and this returns a cJSON object you can interrogate. */
CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);
CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);
/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */
CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);
CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);

/* Render a cJSON entity to text for transfer/storage. */
CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);
/* Render a cJSON entity to text for transfer/storage without any formatting. */
CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);
/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */
CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);
/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */
/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */
CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);
/* Delete a cJSON entity and all subentities. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item);

/* Returns the number of items in an array (or object). */
CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);
/* Retrieve item number "index" from array "array". Returns NULL if unsuccessful. */
CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);
/* Get item "string" from object. Case insensitive. */
CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);
CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);
CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);
/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);

/* Check item type and return its value */
CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);
CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);

/* These functions check the type of an item */
CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);

/* These calls create a cJSON item of the appropriate type. */
CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);
CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);
CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);
/* raw json */
CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw);
CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);

/* Create a string where valuestring references a string so
 * it will not be freed by cJSON_Delete */
CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);
/* Create an object/array that only references it's elements so
 * they will not be freed by cJSON_Delete */
CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);
CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child);

/* These utilities create an Array of count items.
 * The parameter count cannot be greater than the number of elements in the number array, otherwise array access will be out of bounds.*/
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);
CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);
CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);
CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);

/* Append item to the specified array/object. */
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);
/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object.
 * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before
 * writing to `item->string` */
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);
/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);

/* Remove/Detach items from Arrays/Objects. */
CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);
CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);
CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);
CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);

/* Update array items. */
CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);

/* Duplicate a cJSON item */
CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);
/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
 * need to be released. With recurse!=0, it will duplicate any children connected to the item.
 * The item->next and ->prev pointers are always zero on return from Duplicate. */
/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.
 * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */
CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);

/* Minify a strings, remove blank characters(such as ' ', '\t', '\r', '\n') from strings.
 * The input pointer json cannot point to a read-only address area, such as a string constant, 
 * but should point to a readable and writable address area. */
CJSON_PUBLIC(void) cJSON_Minify(char *json);

/* Helper functions for creating and adding items to an object at the same time.
 * They return the added item or NULL on failure. */
CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);
CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);
CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);
CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);
CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);

/* When assigning an integer value, it needs to be propagated to valuedouble too. */
#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))
/* helper for the cJSON_SetNumberValue macro */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number);
#define cJSON_SetNumberValue(object, number) ((object != NULL) ? cJSON_SetNumberHelper(object, (double)number) : (number))
/* Change the valuestring of a cJSON_String object, only takes effect when type of object is cJSON_String */
CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring);

/* If the object is not a boolean type this does nothing and returns cJSON_Invalid else it returns the new type*/
#define cJSON_SetBoolValue(object, boolValue) ( \
    (object != NULL && ((object)->type & (cJSON_False|cJSON_True))) ? \
    (object)->type=((object)->type &(~(cJSON_False|cJSON_True)))|((boolValue)?cJSON_True:cJSON_False) : \
    cJSON_Invalid\
)

/* Macro for iterating over an array or object */
#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)

/* malloc/free objects using the malloc/free functions that have been set with cJSON_InitHooks */
CJSON_PUBLIC(void *) cJSON_malloc(size_t size);
CJSON_PUBLIC(void) cJSON_free(void *object);

#ifdef __cplusplus
}
#endif

#endif

```

// FILE: LICENSE
```
MIT License

Copyright (c) 2025 Browser Selector

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

// FILE: Makefile
```
# Compiler settings
CC = gcc
WINDRES = windres
CFLAGS = -std=c11 -Wall -Wextra -O2 -Iinclude -DUNICODE -D_UNICODE
LDFLAGS = -mwindows -static-libgcc -static
LIBS = -lcomctl32 -ladvapi32 -lshell32 -luser32 -lgdi32 -lkernel32 -lcomdlg32 -lole32

# Directories
SRC_DIR = src
OBJ_DIR = obj
BIN_DIR = bin

# Source files
SOURCES = $(SRC_DIR)/main.c \
          $(SRC_DIR)/config/config.c \
          $(SRC_DIR)/ui/mainwindow.c \
          $(SRC_DIR)/ui/settings.c \
          $(SRC_DIR)/ui/commandeditor.c \
          $(SRC_DIR)/executor/executor.c \
          $(SRC_DIR)/registry/registry.c \
          $(SRC_DIR)/i18n/i18n.c \
          include/cJSON.c

# Object files
OBJECTS = $(OBJ_DIR)/main.o \
          $(OBJ_DIR)/config.o \
          $(OBJ_DIR)/mainwindow.o \
          $(OBJ_DIR)/settings.o \
          $(OBJ_DIR)/commandeditor.o \
          $(OBJ_DIR)/executor.o \
          $(OBJ_DIR)/registry.o \
          $(OBJ_DIR)/i18n.o \
          $(OBJ_DIR)/cJSON.o

RESOURCE_OBJ = $(OBJ_DIR)/app.res

# Target executable
TARGET = $(BIN_DIR)/BrowserSelector.exe

# Default target
all: directories $(TARGET)
	@echo Build complete: $(TARGET)

# Create directories
directories:
	@mkdir -p $(OBJ_DIR)
	@mkdir -p $(BIN_DIR)

# Compile source files
$(OBJ_DIR)/main.o: $(SRC_DIR)/main.c
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR)/config.o: $(SRC_DIR)/config/config.c
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR)/mainwindow.o: $(SRC_DIR)/ui/mainwindow.c
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR)/settings.o: $(SRC_DIR)/ui/settings.c
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR)/commandeditor.o: $(SRC_DIR)/ui/commandeditor.c
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR)/executor.o: $(SRC_DIR)/executor/executor.c
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR)/registry.o: $(SRC_DIR)/registry/registry.c
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR)/i18n.o: $(SRC_DIR)/i18n/i18n.c
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR)/cJSON.o: include/cJSON.c
	$(CC) $(CFLAGS) -c $< -o $@

# Compile resource file with UTF-8 code page
$(RESOURCE_OBJ): resources/app.rc resources/strings.rc
	$(WINDRES) --codepage=65001 -I$(SRC_DIR) resources/app.rc -O coff -o $(RESOURCE_OBJ)

# Link executable
$(TARGET): $(OBJECTS) $(RESOURCE_OBJ)
	$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)

# Clean build files
clean:
	rm -rf $(OBJ_DIR) $(BIN_DIR)
	@echo Clean complete

# Release build (optimized, stripped)
release: CFLAGS += -DNDEBUG -Os
release: LDFLAGS += -s
release: clean all
	@echo Release build complete

# Debug build
debug: CFLAGS += -g -DDEBUG
debug: LDFLAGS = -mconsole -static-libgcc
debug: clean all
	@echo Debug build complete

# Run the application
run: all
	$(TARGET)

# Install (copy to bin with config)
install: all
	cp config.json $(BIN_DIR)/
	@echo Installation complete

.PHONY: all clean release debug run install directories

```

// FILE: README.md
```
<p align="center">
  <img src="resources/logo.png" alt="Browser Selector Logo" width="200"/>
</p>

<h1 align="center">Browser Selector</h1>

<p align="center">
  <img src="https://img.shields.io/github/v/release/ruslan-rv-ua/BrowserSelector" alt="Version">
  <img src="https://img.shields.io/github/license/ruslan-rv-ua/BrowserSelector" alt="License">
  <img src="https://img.shields.io/badge/platform-Windows-blue" alt="Platform">
</p>

<p align="center">
  <strong>Browser Selector</strong> is <strong>an accessible</strong>, portable Windows application that allows you to easily choose which browser to open a link with. When you open a URL, the application presents a menu with your configured browsers for you to choose from.
</p>

## Key Features

- **Accessibility first!**: Works with NVDA and Windows Narrator
- **Multi-language**: Automatic UI language detection (English, Ukrainian, German, French, Spanish, Italian, Polish, Dutch, Portuguese)
- **Clean Interface**
- **Portable**: Single .exe file with JSON configuration
- **Quick Navigation**: Use Arrow keys, Enter, Escape, and numbers 1-9 for quick selection
- **Auto-Open**: Default browser opens automatically after a configurable countdown (1-10 seconds)
- **Flexible Configuration**: Add, edit, and reorder browsers visually through the Settings window

Browser Selector automatically detects your Windows UI language and displays the interface accordingly:
If your Windows language is not supported the application falls back to English.

## Installation

### Using Scoop

```cmd
scoop bucket add ruslan-rv-ua https://github.com/ruslan-rv-ua/scoop-bucket
scoop install browserselector
```

### Manual Installation

**Download** the zip from the [Releases](https://github.com/ruslan-rv-ua/BrowserSelector/releases) page and extract to your desired location.

### Building from Source

If you prefer to build from source, see the [Building from Source](#building-from-source) section below.

## How to Use

### Basic Commands

```cmd
:: Open without URL
BrowserSelector.exe

:: Open with URL
BrowserSelector.exe "https://example.com"

:: Open with local file
BrowserSelector.exe "file:///C:/Users/Test/Desktop/index.html"
```

### Keyboard Shortcuts

- **↑/↓** - Navigate through the browser list
- **Enter** - Open URL with the selected browser
- **1-9** - Select browser by number
- **Escape** - Close Browser Selector without opening any link
- **Tab** - Switch focus between list and buttons
- **Any Key** - Pause/Cancel the auto-open timer

### Auto-Open Timer

The application features an auto-open timer that automatically launches the default browser after a configured wait time:

- **Default time**: 10 seconds
- **Configurable range**: 1-10 seconds
- **Visual countdown**: Shows remaining seconds in the main window
- **Cancel on interaction**: Any user action cancels the timer
- **Settings**: Configure wait time in the settings window

## Browser Configuration

### Settings Window

Click the **"Settings"** button to access configuration:

- **Add browsers**: Click "Add" to add a new browser
- **Edit**: Select a browser and click "Edit"
- **Delete**: Select a browser and click "Delete"
- **Reorder**: Use "Up"/"Down" to change order
- **Auto-open time**: Configure `Wait Time` (1-10 seconds)

### Configuration File Format

The `config.json` file is stored in the same directory as the executable:

```json
{
  "settings": {
    "defaultCommandIndex": 1,
    "waitTime": 10
  },
  "commands": [
    {
      "name": "Copy to Clipboard",
      "command": "echo {url} | clip"
    },
    {
      "name": "Chrome Incognito",
      "command": "chrome.exe --incognito {url}"
    },
    {
      "name": "Firefox Profile",
      "command": "firefox.exe -P default {url}"
    },
    {
      "name": "Helium",
      "command": "helium.exe {url}"
    },
    {
      "name": "Firefox Private",
      "command": "firefox.exe -private-window {url}"
    },
    {
      "name": "Edge with specific profile",
      "command": "msedge.exe --profile-directory=\"Default\" {url}"
    },
    {
      "name": "Chrome",
      "command": "chrome.exe {url}"
    },
    {
      "name": "Firefox",
      "command": "C:\\Program Files\\Mozilla Firefox\\firefox.exe {url}"
    }
  ]
}
```

#### Field Descriptions

- **name**: Display name in the selector
- **command**: Full command to execute. Use `{url}` as placeholder for the URL. Can include shell commands, pipes, and arguments
- **defaultCommandIndex**: Index of the default browser (0-based)
- **waitTime**: Auto-open timer duration in seconds (1-10, default: 10)

## Default Browser Registration

### Registration Process

1. Click the **"Set as Default"** button
2. Windows Settings will open automatically
3. Scroll to the **Web browser** section
4. Click on the current browser name
5. Select **BrowserSelector** from the list
6. Close Settings and return to the app
7. Click "Yes" to confirm the changes

### Button States

- **"Set as Default"** - when the app is not registered or not set as default browser
- **"Unregister"** - when already set as default browser

---

## Technical Documentation

### System Requirements

- **Operating System**: Windows 10/11 (x64)
- **Runtime**: No additional libraries required (statically compiled)
- **Space**: ~500KB-1MB on disk

### Building from Source

#### Prerequisites

1. **MinGW-w64 GCC** (8.1.0 or newer)
   - Install via MSYS2: `pacman -S mingw-w64-x86_64-gcc`
   - Or download from [winlibs.com](https://winlibs.com/)

2. **Make** (optional, for Makefile usage)
   - Install via MSYS2: `pacman -S mingw-w64-x86_64-make`

3. Add MinGW bin directory to PATH (e.g., `C:\msys64\mingw64\bin`)

#### Build Commands

```cmd
:: Build the project
make

:: Build release version (optimized)
make release

:: Build and copy config.json to bin
make install

:: Clean build files
make clean

:: Build and run
make run
```

#### Manual Build (without Make)

```cmd
:: Create directories
mkdir obj
mkdir bin

:: Compile source files
gcc -std=c11 -Wall -O2 -Iinclude -c src/main.c -o obj/main.o
gcc -std=c11 -Wall -O2 -Iinclude -c src/config/config.c -o obj/config.o
gcc -std=c11 -Wall -O2 -Iinclude -c src/ui/mainwindow.c -o obj/mainwindow.o
gcc -std=c11 -Wall -O2 -Iinclude -c src/ui/settings.c -o obj/settings.o
gcc -std=c11 -Wall -O2 -Iinclude -c src/ui/commandeditor.c -o obj/commandeditor.o
gcc -std=c11 -Wall -O2 -Iinclude -c src/executor/executor.c -o obj/executor.o
gcc -std=c11 -Wall -O2 -Iinclude -c src/registry/registry.c -o obj/registry.o
gcc -std=c11 -Wall -O2 -Iinclude -c include/cJSON.c -o obj/cJSON.o

:: Compile resources
windres -i resources/app.rc -o obj/app.res

:: Link
gcc -mwindows -static-libgcc -static -o bin/BrowserSelector.exe ^
    obj/main.o obj/config.o obj/mainwindow.o obj.settings.o ^
    obj/commandeditor.o obj/executor.o obj.registry.o obj.cJSON.o obj.app.res ^
    -lcomctl32 -ladvapi32 -lshell32 -luser32 -lgdi32 -lkernel32 -lcomdlg32 -lole32

:: Copy configuration
copy config.json bin\
```

### Project Structure

- `src/` - Source code
  - `ui/` - Interface logic (GDI/WinAPI)
  - `config/` - JSON configuration handling
  - `registry/` - Windows Registry operations
  - `i18n/` - Internationalization helper functions
- `resources/` - Icons, localized strings (`strings.rc`)
- `include/` - Header files and external libraries (cJSON)

### Adding Translations

Localization is handled via Windows Resource files which allows the app to automatically adapt to the user's OS language. To add a new language:

1. Open `resources/strings.rc`.
2. Add a new `STRINGTABLE` block with the appropriate `LANGUAGE` identifier.
3. Translate the string definitions.
4. Rebuild the project.

## Troubleshooting

### Configuration file is corrupted
If `config.json` becomes invalid or corrupted, the application will detect this on startup. It will attempt to create a new default configuration file. You can also manually delete `config.json` to force a reset.

### Browser not opening
- Check if the command in `config.json` is correct.
- If using just the executable name (e.g., `chrome.exe`), ensure it is available in your system's PATH.
- Verify that the `{url}` placeholder is present in the command if needed.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the project
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

MIT License

## Credits

- [cJSON](https://github.com/DaveGamble/cJSON) - JSON parsing library

```

// FILE: resources/app.rc
```
#include <windows.h>

// Include string resources for all languages
#include "strings.rc"

// Application icon
1 ICON "icon.ico"

// Version information
VS_VERSION_INFO VERSIONINFO
FILEVERSION     0,1,2,0
PRODUCTVERSION  0,1,2,0
FILEFLAGSMASK   0x3fL
FILEFLAGS       0x0L
FILEOS          VOS_NT_WINDOWS32
FILETYPE        VFT_APP
FILESUBTYPE     VFT2_UNKNOWN
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName",      "Ruslan Iskov\0"
            VALUE "Author",           "Ruslan Iskov <ruslan.rv.ua+github@gmail.com>\0"
            VALUE "FileDescription",  "Browser Selector\0"
            VALUE "FileVersion",      "0.1.2.0\0"
            VALUE "InternalName",     "BrowserSelector\0"
            VALUE "LegalCopyright",   "Copyright (C) 2025\0"
            VALUE "OriginalFilename", "BrowserSelector.exe\0"
            VALUE "ProductName",      "Browser Selector\0"
            VALUE "ProductVersion",   "0.1.2.0\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

// Application manifest
1 RT_MANIFEST "manifest.xml"

```

// FILE: resources/manifest.xml
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <assemblyIdentity
    version="0.1.2.0"
    processorArchitecture="*"
    name="BrowserSelector"
    type="win32"/>
  <description>Browser Selector Application</description>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
        type="win32"
        name="Microsoft.Windows.Common-Controls"
        version="6.0.0.0"
        processorArchitecture="*"
        publicKeyToken="6595b64144ccf1df"
        language="*"/>
    </dependentAssembly>
  </dependency>
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>

```

// FILE: resources/strings.rc
```
// String resources for Browser Selector
// This file contains all localized strings embedded in the executable

#include <windows.h>
#include "../src/i18n/i18n.h"

// ============================================================================
// ENGLISH (Default/Neutral) - LANG_ENGLISH, SUBLANG_NEUTRAL
// ============================================================================
LANGUAGE LANG_ENGLISH, SUBLANG_NEUTRAL
#pragma code_page(65001)

STRINGTABLE
BEGIN
    // Main window
    IDS_APP_TITLE               "Browser Selector"
    IDS_SETTINGS_BTN            "Settings"
    IDS_SET_DEFAULT_BTN         "Set as default browser"
    IDS_UNREGISTER_BTN          "Unregister as default"
    IDS_COUNTDOWN_SECONDS       "Opening default browser in %d seconds..."
    IDS_COUNTDOWN_SECOND        "Opening default browser in 1 second..."
    IDS_COUNTDOWN_NOW           "Opening default browser now..."
END

STRINGTABLE
BEGIN
    // Settings window
    IDS_SETTINGS_TITLE          "Settings - Browser Selector"
    IDS_ADD_BTN                 "Add"
    IDS_EDIT_BTN                "Edit"
    IDS_DELETE_BTN              "Delete"
    IDS_MOVE_UP_BTN             "Move Up"
    IDS_MOVE_DOWN_BTN           "Move Down"
    IDS_SET_DEFAULT_CMD_BTN     "Set Default"
    IDS_CLOSE_BTN               "Close"
    IDS_WAITTIME_LABEL          "Wait Time (1-10 sec):"
    IDS_DEFAULT_MARKER          "[default]"
    IDS_MAX_COMMANDS_WARNING    "Maximum number of commands reached"
    IDS_CONFIRM_DELETE_TITLE    "Confirm Delete"
    IDS_CONFIRM_DELETE_MSG      "Delete '%s'?"
END

STRINGTABLE
BEGIN
    // Command editor
    IDS_ADD_BROWSER_TITLE       "Add Browser"
    IDS_EDIT_BROWSER_TITLE      "Edit Browser"
    IDS_NAME_LABEL              "Name:"
    IDS_COMMAND_LABEL           "Command:"
    IDS_URL_PLACEHOLDER_HINT    "Use {url} for URL placeholder. Example: chrome.exe {url}"
    IDS_OK_BTN                  "OK"
    IDS_CANCEL_BTN              "Cancel"
    IDS_BROWSE_TITLE            "Select Browser Executable"
    IDS_BROWSE_FILTER_EXE       "Executable Files (*.exe)"
    IDS_BROWSE_FILTER_ALL       "All Files (*.*)"
    IDS_VALIDATION_NAME_EMPTY   "Name cannot be empty"
    IDS_VALIDATION_CMD_EMPTY    "Command cannot be empty"
    IDS_VALIDATION_ERROR_TITLE  "Validation Error"
END

STRINGTABLE
BEGIN
    // Error messages
    IDS_ERROR                   "Error"
    IDS_WARNING                 "Warning"
    IDS_SUCCESS                 "Success"
    IDS_CMD_NOT_FOUND           "Command not found: %s"
    IDS_CMD_NOT_FOUND_HINT      "Make sure the program is installed and in your PATH, or use an absolute path."
    IDS_LAUNCH_FAILED           "Failed to launch: %s\nError code: %lu"
    IDS_MEMORY_ERROR            "Failed to allocate memory"
END

STRINGTABLE
BEGIN
    // Registration messages
    IDS_REG_SUCCESS_TITLE       "Registration Successful"
    IDS_REG_SUCCESS_MSG         "Browser Selector has been set as your default browser!\n\nAll web links will now open through Browser Selector."
    IDS_REG_FAILED_TITLE        "Registration Failed"
    IDS_REG_FAILED_MSG          "Failed to register Browser Selector.\n\nTry running as administrator."
    IDS_UNREG_SUCCESS_TITLE     "Unregistration Successful"
    IDS_UNREG_SUCCESS_MSG       "Browser Selector has been unregistered.\n\nIt will no longer appear in the list of available browsers."
    IDS_UNREG_FAILED_TITLE      "Unregistration Failed"
    IDS_UNREG_FAILED_MSG        "Failed to unregister Browser Selector.\n\nPlease check permissions and try again."
    IDS_SET_DEFAULT_TITLE       "Set as Default Browser"
    IDS_SET_DEFAULT_MSG         "Please select Browser Selector as your default browser.\n\nSteps in Windows Settings:\n1. Scroll to 'Web browser'\n2. Click the current browser name\n3. Select 'BrowserSelector' from the list"
    IDS_VERIFY_TITLE            "Verification"
    IDS_VERIFY_MSG              "Windows Settings has been opened for manual selection.\n\nAfter selecting Browser Selector, click 'Yes' to verify.\n\nHave you completed the selection?"
    IDS_NOW_DEFAULT_MSG         "Browser Selector is now your default browser!"
    IDS_NOT_DEFAULT_MSG         "Browser Selector is not yet set as default.\n\nPlease make sure to select 'BrowserSelector' in Windows Settings."
END

STRINGTABLE
BEGIN
    // Main application messages
    IDS_CONFIG_LOAD_FAILED      "Failed to load configuration"
    IDS_CONFIG_LOAD_FAILED_MSG  "Failed to load configuration."
    IDS_CONFIG_CREATE_FAILED    "Failed to create default configuration."
    IDS_CONFIG_LOAD_RETRY_FAIL  "Failed to load configuration after creating default."
    IDS_NO_BROWSERS_TITLE       "No Browsers"
    IDS_NO_BROWSERS_MSG         "No browsers configured.\n\nThe settings window will open to add browsers."
    IDS_WINDOW_CREATE_FAILED    "Failed to create main window."
    IDS_CONFIG_CORRUPTED_MSG    "Configuration file is corrupted and cannot be read.\n\nCreate new default configuration?"
    IDS_CONFIG_CREATE_BTN       "Create config"
    IDS_CONFIG_EXIT_BTN         "Exit"
END


// ============================================================================
// UKRAINIAN - LANG_UKRAINIAN, SUBLANG_DEFAULT
// ============================================================================
LANGUAGE LANG_UKRAINIAN, SUBLANG_DEFAULT
#pragma code_page(65001)

STRINGTABLE
BEGIN
    // Main window
    IDS_APP_TITLE               "Вибір браузера"
    IDS_SETTINGS_BTN            "Налаштування"
    IDS_SET_DEFAULT_BTN         "Встановити за замовчуванням"
    IDS_UNREGISTER_BTN          "Скасувати реєстрацію"
    IDS_COUNTDOWN_SECONDS       "Відкриття браузера за замовчуванням через %d сек..."
    IDS_COUNTDOWN_SECOND        "Відкриття браузера за замовчуванням через 1 сек..."
    IDS_COUNTDOWN_NOW           "Відкриття браузера за замовчуванням..."
END

STRINGTABLE
BEGIN
    // Settings window
    IDS_SETTINGS_TITLE          "Налаштування - Вибір браузера"
    IDS_ADD_BTN                 "Додати"
    IDS_EDIT_BTN                "Редагувати"
    IDS_DELETE_BTN              "Видалити"
    IDS_MOVE_UP_BTN             "Вгору"
    IDS_MOVE_DOWN_BTN           "Вниз"
    IDS_SET_DEFAULT_CMD_BTN     "За замовч."
    IDS_CLOSE_BTN               "Закрити"
    IDS_WAITTIME_LABEL          "Час очікування (1-10 сек):"
    IDS_DEFAULT_MARKER          "[за замовч.]"
    IDS_MAX_COMMANDS_WARNING    "Досягнуто максимальну кількість команд"
    IDS_CONFIRM_DELETE_TITLE    "Підтвердження видалення"
    IDS_CONFIRM_DELETE_MSG      "Видалити '%s'?"
END

STRINGTABLE
BEGIN
    // Command editor
    IDS_ADD_BROWSER_TITLE       "Додати браузер"
    IDS_EDIT_BROWSER_TITLE      "Редагувати браузер"
    IDS_NAME_LABEL              "Назва:"
    IDS_COMMAND_LABEL           "Команда:"
    IDS_URL_PLACEHOLDER_HINT    "Використовуйте {url} для URL. Приклад: chrome.exe {url}"
    IDS_OK_BTN                  "OK"
    IDS_CANCEL_BTN              "Скасувати"
    IDS_BROWSE_TITLE            "Виберіть виконуваний файл браузера"
    IDS_BROWSE_FILTER_EXE       "Виконувані файли (*.exe)"
    IDS_BROWSE_FILTER_ALL       "Усі файли (*.*)"
    IDS_VALIDATION_NAME_EMPTY   "Назва не може бути порожньою"
    IDS_VALIDATION_CMD_EMPTY    "Команда не може бути порожньою"
    IDS_VALIDATION_ERROR_TITLE  "Помилка перевірки"
END

STRINGTABLE
BEGIN
    // Error messages
    IDS_ERROR                   "Помилка"
    IDS_WARNING                 "Попередження"
    IDS_SUCCESS                 "Успіх"
    IDS_CMD_NOT_FOUND           "Команду не знайдено: %s"
    IDS_CMD_NOT_FOUND_HINT      "Переконайтесь, що програма встановлена та є в PATH, або вкажіть повний шлях."
    IDS_LAUNCH_FAILED           "Не вдалося запустити: %s\nКод помилки: %lu"
    IDS_MEMORY_ERROR            "Не вдалося виділити пам'ять"
END

STRINGTABLE
BEGIN
    // Registration messages
    IDS_REG_SUCCESS_TITLE       "Реєстрація успішна"
    IDS_REG_SUCCESS_MSG         "Browser Selector встановлено браузером за замовчуванням!\n\nУсі посилання тепер відкриватимуться через Browser Selector."
    IDS_REG_FAILED_TITLE        "Помилка реєстрації"
    IDS_REG_FAILED_MSG          "Не вдалося зареєструвати Browser Selector.\n\nСпробуйте запустити від імені адміністратора."
    IDS_UNREG_SUCCESS_TITLE     "Скасування реєстрації успішне"
    IDS_UNREG_SUCCESS_MSG       "Browser Selector було скасовано реєстрацію.\n\nВін більше не з'являтиметься у списку доступних браузерів."
    IDS_UNREG_FAILED_TITLE      "Помилка скасування реєстрації"
    IDS_UNREG_FAILED_MSG        "Не вдалося скасувати реєстрацію Browser Selector.\n\nПеревірте дозволи та спробуйте знову."
    IDS_SET_DEFAULT_TITLE       "Встановити браузером за замовчуванням"
    IDS_SET_DEFAULT_MSG         "Будь ласка, виберіть Browser Selector як браузер за замовчуванням.\n\nКроки в налаштуваннях Windows:\n1. Прокрутіть до 'Веб-браузер'\n2. Натисніть на поточний браузер\n3. Виберіть 'BrowserSelector' зі списку"
    IDS_VERIFY_TITLE            "Перевірка"
    IDS_VERIFY_MSG              "Відкрито налаштування Windows для ручного вибору.\n\nПісля вибору Browser Selector натисніть 'Так' для перевірки.\n\nВи завершили вибір?"
    IDS_NOW_DEFAULT_MSG         "Browser Selector тепер ваш браузер за замовчуванням!"
    IDS_NOT_DEFAULT_MSG         "Browser Selector ще не встановлено за замовчуванням.\n\nБудь ласка, виберіть 'BrowserSelector' в налаштуваннях Windows."
END

STRINGTABLE
BEGIN
    // Main application messages
    IDS_CONFIG_LOAD_FAILED      "Не вдалося завантажити конфігурацію"
    IDS_CONFIG_LOAD_FAILED_MSG  "Не вдалося завантажити конфігурацію."
    IDS_CONFIG_CREATE_FAILED    "Не вдалося створити конфігурацію за замовчуванням."
    IDS_CONFIG_LOAD_RETRY_FAIL  "Не вдалося завантажити конфігурацію після створення."
    IDS_NO_BROWSERS_TITLE       "Немає браузерів"
    IDS_NO_BROWSERS_MSG         "Браузери не налаштовані.\n\nВідкриється вікно налаштувань для додавання браузерів."
    IDS_WINDOW_CREATE_FAILED    "Не вдалося створити головне вікно."
    IDS_CONFIG_CORRUPTED_MSG    "Файл конфігурації пошкоджений і не може бути прочитаний.\n\nСтворити нову конфігурацію за замовчуванням?"
    IDS_CONFIG_CREATE_BTN       "Створити конфіг"
    IDS_CONFIG_EXIT_BTN         "Вийти"
END


// ============================================================================
// GERMAN - LANG_GERMAN, SUBLANG_DEFAULT
// ============================================================================
LANGUAGE LANG_GERMAN, SUBLANG_DEFAULT
#pragma code_page(65001)

STRINGTABLE
BEGIN
    // Main window
    IDS_APP_TITLE               "Browser-Auswahl"
    IDS_SETTINGS_BTN            "Einstellungen"
    IDS_SET_DEFAULT_BTN         "Als Standard festlegen"
    IDS_UNREGISTER_BTN          "Registrierung aufheben"
    IDS_COUNTDOWN_SECONDS       "Standardbrowser wird in %d Sekunden geöffnet..."
    IDS_COUNTDOWN_SECOND        "Standardbrowser wird in 1 Sekunde geöffnet..."
    IDS_COUNTDOWN_NOW           "Standardbrowser wird jetzt geöffnet..."
END

STRINGTABLE
BEGIN
    // Settings window
    IDS_SETTINGS_TITLE          "Einstellungen - Browser-Auswahl"
    IDS_ADD_BTN                 "Hinzufügen"
    IDS_EDIT_BTN                "Bearbeiten"
    IDS_DELETE_BTN              "Löschen"
    IDS_MOVE_UP_BTN             "Nach oben"
    IDS_MOVE_DOWN_BTN           "Nach unten"
    IDS_SET_DEFAULT_CMD_BTN     "Als Standard"
    IDS_CLOSE_BTN               "Schließen"
    IDS_WAITTIME_LABEL          "Wartezeit (1-10 Sek):"
    IDS_DEFAULT_MARKER          "[Standard]"
    IDS_MAX_COMMANDS_WARNING    "Maximale Anzahl an Befehlen erreicht"
    IDS_CONFIRM_DELETE_TITLE    "Löschen bestätigen"
    IDS_CONFIRM_DELETE_MSG      "'%s' löschen?"
END

STRINGTABLE
BEGIN
    // Command editor
    IDS_ADD_BROWSER_TITLE       "Browser hinzufügen"
    IDS_EDIT_BROWSER_TITLE      "Browser bearbeiten"
    IDS_NAME_LABEL              "Name:"
    IDS_COMMAND_LABEL           "Befehl:"
    IDS_URL_PLACEHOLDER_HINT    "Verwenden Sie {url} für URL. Beispiel: chrome.exe {url}"
    IDS_OK_BTN                  "OK"
    IDS_CANCEL_BTN              "Abbrechen"
    IDS_BROWSE_TITLE            "Browser-Programm auswählen"
    IDS_BROWSE_FILTER_EXE       "Ausführbare Dateien (*.exe)"
    IDS_BROWSE_FILTER_ALL       "Alle Dateien (*.*)"
    IDS_VALIDATION_NAME_EMPTY   "Name darf nicht leer sein"
    IDS_VALIDATION_CMD_EMPTY    "Befehl darf nicht leer sein"
    IDS_VALIDATION_ERROR_TITLE  "Validierungsfehler"
END

STRINGTABLE
BEGIN
    // Error messages
    IDS_ERROR                   "Fehler"
    IDS_WARNING                 "Warnung"
    IDS_SUCCESS                 "Erfolg"
    IDS_CMD_NOT_FOUND           "Befehl nicht gefunden: %s"
    IDS_CMD_NOT_FOUND_HINT      "Stellen Sie sicher, dass das Programm installiert und im PATH ist, oder verwenden Sie einen absoluten Pfad."
    IDS_LAUNCH_FAILED           "Starten fehlgeschlagen: %s\nFehlercode: %lu"
    IDS_MEMORY_ERROR            "Speicherzuweisung fehlgeschlagen"
END

STRINGTABLE
BEGIN
    // Registration messages
    IDS_REG_SUCCESS_TITLE       "Registrierung erfolgreich"
    IDS_REG_SUCCESS_MSG         "Browser Selector wurde als Standardbrowser festgelegt!\n\nAlle Weblinks werden nun über Browser Selector geöffnet."
    IDS_REG_FAILED_TITLE        "Registrierung fehlgeschlagen"
    IDS_REG_FAILED_MSG          "Browser Selector konnte nicht registriert werden.\n\nVersuchen Sie, als Administrator auszuführen."
    IDS_UNREG_SUCCESS_TITLE     "Registrierung aufgehoben"
    IDS_UNREG_SUCCESS_MSG       "Browser Selector wurde abgemeldet.\n\nEr erscheint nicht mehr in der Liste der verfügbaren Browser."
    IDS_UNREG_FAILED_TITLE      "Aufheben fehlgeschlagen"
    IDS_UNREG_FAILED_MSG        "Browser Selector konnte nicht abgemeldet werden.\n\nBitte überprüfen Sie die Berechtigungen und versuchen Sie es erneut."
    IDS_SET_DEFAULT_TITLE       "Als Standardbrowser festlegen"
    IDS_SET_DEFAULT_MSG         "Bitte wählen Sie Browser Selector als Standardbrowser.\n\nSchritte in Windows-Einstellungen:\n1. Scrollen Sie zu 'Webbrowser'\n2. Klicken Sie auf den aktuellen Browser\n3. Wählen Sie 'BrowserSelector' aus der Liste"
    IDS_VERIFY_TITLE            "Überprüfung"
    IDS_VERIFY_MSG              "Windows-Einstellungen wurden zur manuellen Auswahl geöffnet.\n\nNach Auswahl von Browser Selector klicken Sie auf 'Ja' zur Überprüfung.\n\nHaben Sie die Auswahl abgeschlossen?"
    IDS_NOW_DEFAULT_MSG         "Browser Selector ist jetzt Ihr Standardbrowser!"
    IDS_NOT_DEFAULT_MSG         "Browser Selector ist noch nicht als Standard festgelegt.\n\nBitte wählen Sie 'BrowserSelector' in den Windows-Einstellungen."
END

STRINGTABLE
BEGIN
    // Main application messages
    IDS_CONFIG_LOAD_FAILED      "Konfiguration konnte nicht geladen werden"
    IDS_CONFIG_LOAD_FAILED_MSG  "Konfiguration konnte nicht geladen werden."
    IDS_CONFIG_CREATE_FAILED    "Standardkonfiguration konnte nicht erstellt werden."
    IDS_CONFIG_LOAD_RETRY_FAIL  "Konfiguration konnte nach dem Erstellen nicht geladen werden."
    IDS_NO_BROWSERS_TITLE       "Keine Browser"
    IDS_NO_BROWSERS_MSG         "Keine Browser konfiguriert.\n\nDas Einstellungsfenster wird zum Hinzufügen von Browsern geöffnet."
    IDS_WINDOW_CREATE_FAILED    "Hauptfenster konnte nicht erstellt werden."
    IDS_CONFIG_CORRUPTED_MSG    "Konfigurationsdatei ist beschädigt und kann nicht gelesen werden.\n\nNeue Standardkonfiguration erstellen?"
    IDS_CONFIG_CREATE_BTN       "Konfig erstellen"
    IDS_CONFIG_EXIT_BTN         "Beenden"
END


// ============================================================================
// FRENCH - LANG_FRENCH, SUBLANG_DEFAULT
// ============================================================================
LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
#pragma code_page(65001)

STRINGTABLE
BEGIN
    // Main window
    IDS_APP_TITLE               "Sélecteur de navigateur"
    IDS_SETTINGS_BTN            "Paramètres"
    IDS_SET_DEFAULT_BTN         "Définir par défaut"
    IDS_UNREGISTER_BTN          "Annuler l'inscription"
    IDS_COUNTDOWN_SECONDS       "Ouverture du navigateur par défaut dans %d secondes..."
    IDS_COUNTDOWN_SECOND        "Ouverture du navigateur par défaut dans 1 seconde..."
    IDS_COUNTDOWN_NOW           "Ouverture du navigateur par défaut..."
END

STRINGTABLE
BEGIN
    // Settings window
    IDS_SETTINGS_TITLE          "Paramètres - Sélecteur de navigateur"
    IDS_ADD_BTN                 "Ajouter"
    IDS_EDIT_BTN                "Modifier"
    IDS_DELETE_BTN              "Supprimer"
    IDS_MOVE_UP_BTN             "Monter"
    IDS_MOVE_DOWN_BTN           "Descendre"
    IDS_SET_DEFAULT_CMD_BTN     "Par défaut"
    IDS_CLOSE_BTN               "Fermer"
    IDS_WAITTIME_LABEL          "Délai d'attente (1-10 sec):"
    IDS_DEFAULT_MARKER          "[par défaut]"
    IDS_MAX_COMMANDS_WARNING    "Nombre maximum de commandes atteint"
    IDS_CONFIRM_DELETE_TITLE    "Confirmer la suppression"
    IDS_CONFIRM_DELETE_MSG      "Supprimer '%s'?"
END

STRINGTABLE
BEGIN
    // Command editor
    IDS_ADD_BROWSER_TITLE       "Ajouter un navigateur"
    IDS_EDIT_BROWSER_TITLE      "Modifier le navigateur"
    IDS_NAME_LABEL              "Nom:"
    IDS_COMMAND_LABEL           "Commande:"
    IDS_URL_PLACEHOLDER_HINT    "Utilisez {url} pour l'URL. Exemple: chrome.exe {url}"
    IDS_OK_BTN                  "OK"
    IDS_CANCEL_BTN              "Annuler"
    IDS_BROWSE_TITLE            "Sélectionner l'exécutable du navigateur"
    IDS_BROWSE_FILTER_EXE       "Fichiers exécutables (*.exe)"
    IDS_BROWSE_FILTER_ALL       "Tous les fichiers (*.*)"
    IDS_VALIDATION_NAME_EMPTY   "Le nom ne peut pas être vide"
    IDS_VALIDATION_CMD_EMPTY    "La commande ne peut pas être vide"
    IDS_VALIDATION_ERROR_TITLE  "Erreur de validation"
END

STRINGTABLE
BEGIN
    // Error messages
    IDS_ERROR                   "Erreur"
    IDS_WARNING                 "Avertissement"
    IDS_SUCCESS                 "Succès"
    IDS_CMD_NOT_FOUND           "Commande non trouvée: %s"
    IDS_CMD_NOT_FOUND_HINT      "Assurez-vous que le programme est installé et dans le PATH, ou utilisez un chemin absolu."
    IDS_LAUNCH_FAILED           "Échec du lancement: %s\nCode d'erreur: %lu"
    IDS_MEMORY_ERROR            "Échec de l'allocation de mémoire"
END

STRINGTABLE
BEGIN
    // Registration messages
    IDS_REG_SUCCESS_TITLE       "Inscription réussie"
    IDS_REG_SUCCESS_MSG         "Browser Selector est maintenant votre navigateur par défaut!\n\nTous les liens web s'ouvriront via Browser Selector."
    IDS_REG_FAILED_TITLE        "Échec de l'inscription"
    IDS_REG_FAILED_MSG          "Impossible d'inscrire Browser Selector.\n\nEssayez d'exécuter en tant qu'administrateur."
    IDS_UNREG_SUCCESS_TITLE     "Désinscription réussie"
    IDS_UNREG_SUCCESS_MSG       "Browser Selector a été désinscrit.\n\nIl n'apparaîtra plus dans la liste des navigateurs disponibles."
    IDS_UNREG_FAILED_TITLE      "Échec de la désinscription"
    IDS_UNREG_FAILED_MSG        "Impossible de désinscrire Browser Selector.\n\nVérifiez les autorisations et réessayez."
    IDS_SET_DEFAULT_TITLE       "Définir comme navigateur par défaut"
    IDS_SET_DEFAULT_MSG         "Veuillez sélectionner Browser Selector comme navigateur par défaut.\n\nÉtapes dans les paramètres Windows:\n1. Faites défiler jusqu'à 'Navigateur web'\n2. Cliquez sur le navigateur actuel\n3. Sélectionnez 'BrowserSelector' dans la liste"
    IDS_VERIFY_TITLE            "Vérification"
    IDS_VERIFY_MSG              "Les paramètres Windows ont été ouverts pour la sélection manuelle.\n\nAprès avoir sélectionné Browser Selector, cliquez sur 'Oui' pour vérifier.\n\nAvez-vous terminé la sélection?"
    IDS_NOW_DEFAULT_MSG         "Browser Selector est maintenant votre navigateur par défaut!"
    IDS_NOT_DEFAULT_MSG         "Browser Selector n'est pas encore défini par défaut.\n\nVeuillez sélectionner 'BrowserSelector' dans les paramètres Windows."
END

STRINGTABLE
BEGIN
    // Main application messages
    IDS_CONFIG_LOAD_FAILED      "Échec du chargement de la configuration"
    IDS_CONFIG_LOAD_FAILED_MSG  "Échec du chargement de la configuration."
    IDS_CONFIG_CREATE_FAILED    "Échec de la création de la configuration par défaut."
    IDS_CONFIG_LOAD_RETRY_FAIL  "Échec du chargement de la configuration après création."
    IDS_NO_BROWSERS_TITLE       "Aucun navigateur"
    IDS_NO_BROWSERS_MSG         "Aucun navigateur configuré.\n\nLa fenêtre des paramètres s'ouvrira pour ajouter des navigateurs."
    IDS_WINDOW_CREATE_FAILED    "Échec de la création de la fenêtre principale."
    IDS_CONFIG_CORRUPTED_MSG    "Le fichier de configuration est corrompu et ne peut pas être lu.\n\nCréer une nouvelle configuration par défaut?"
    IDS_CONFIG_CREATE_BTN       "Créer config"
    IDS_CONFIG_EXIT_BTN         "Quitter"
END


// ============================================================================
// SPANISH - LANG_SPANISH, SUBLANG_DEFAULT
// ============================================================================
LANGUAGE LANG_SPANISH, SUBLANG_DEFAULT
#pragma code_page(65001)

STRINGTABLE
BEGIN
    // Main window
    IDS_APP_TITLE               "Selector de navegador"
    IDS_SETTINGS_BTN            "Configuración"
    IDS_SET_DEFAULT_BTN         "Establecer por defecto"
    IDS_UNREGISTER_BTN          "Anular registro"
    IDS_COUNTDOWN_SECONDS       "Abriendo navegador predeterminado en %d segundos..."
    IDS_COUNTDOWN_SECOND        "Abriendo navegador predeterminado en 1 segundo..."
    IDS_COUNTDOWN_NOW           "Abriendo navegador predeterminado..."
END

STRINGTABLE
BEGIN
    // Settings window
    IDS_SETTINGS_TITLE          "Configuración - Selector de navegador"
    IDS_ADD_BTN                 "Añadir"
    IDS_EDIT_BTN                "Editar"
    IDS_DELETE_BTN              "Eliminar"
    IDS_MOVE_UP_BTN             "Subir"
    IDS_MOVE_DOWN_BTN           "Bajar"
    IDS_SET_DEFAULT_CMD_BTN     "Por defecto"
    IDS_CLOSE_BTN               "Cerrar"
    IDS_WAITTIME_LABEL          "Tiempo de espera (1-10 seg):"
    IDS_DEFAULT_MARKER          "[por defecto]"
    IDS_MAX_COMMANDS_WARNING    "Número máximo de comandos alcanzado"
    IDS_CONFIRM_DELETE_TITLE    "Confirmar eliminación"
    IDS_CONFIRM_DELETE_MSG      "¿Eliminar '%s'?"
END

STRINGTABLE
BEGIN
    // Command editor
    IDS_ADD_BROWSER_TITLE       "Añadir navegador"
    IDS_EDIT_BROWSER_TITLE      "Editar navegador"
    IDS_NAME_LABEL              "Nombre:"
    IDS_COMMAND_LABEL           "Comando:"
    IDS_URL_PLACEHOLDER_HINT    "Use {url} para URL. Ejemplo: chrome.exe {url}"
    IDS_OK_BTN                  "Aceptar"
    IDS_CANCEL_BTN              "Cancelar"
    IDS_BROWSE_TITLE            "Seleccionar ejecutable del navegador"
    IDS_BROWSE_FILTER_EXE       "Archivos ejecutables (*.exe)"
    IDS_BROWSE_FILTER_ALL       "Todos los archivos (*.*)"
    IDS_VALIDATION_NAME_EMPTY   "El nombre no puede estar vacío"
    IDS_VALIDATION_CMD_EMPTY    "El comando no puede estar vacío"
    IDS_VALIDATION_ERROR_TITLE  "Error de validación"
END

STRINGTABLE
BEGIN
    // Error messages
    IDS_ERROR                   "Error"
    IDS_WARNING                 "Advertencia"
    IDS_SUCCESS                 "Éxito"
    IDS_CMD_NOT_FOUND           "Comando no encontrado: %s"
    IDS_CMD_NOT_FOUND_HINT      "Asegúrese de que el programa está instalado y en el PATH, o use una ruta absoluta."
    IDS_LAUNCH_FAILED           "Error al iniciar: %s\nCódigo de error: %lu"
    IDS_MEMORY_ERROR            "Error al asignar memoria"
END

STRINGTABLE
BEGIN
    // Registration messages
    IDS_REG_SUCCESS_TITLE       "Registro exitoso"
    IDS_REG_SUCCESS_MSG         "¡Browser Selector se ha establecido como su navegador predeterminado!\n\nTodos los enlaces web se abrirán a través de Browser Selector."
    IDS_REG_FAILED_TITLE        "Error de registro"
    IDS_REG_FAILED_MSG          "No se pudo registrar Browser Selector.\n\nIntente ejecutar como administrador."
    IDS_UNREG_SUCCESS_TITLE     "Anulación de registro exitosa"
    IDS_UNREG_SUCCESS_MSG       "Browser Selector ha sido dado de baja.\n\nYa no aparecerá en la lista de navegadores disponibles."
    IDS_UNREG_FAILED_TITLE      "Error al anular registro"
    IDS_UNREG_FAILED_MSG        "No se pudo anular el registro de Browser Selector.\n\nVerifique los permisos e intente de nuevo."
    IDS_SET_DEFAULT_TITLE       "Establecer como navegador predeterminado"
    IDS_SET_DEFAULT_MSG         "Por favor, seleccione Browser Selector como su navegador predeterminado.\n\nPasos en Configuración de Windows:\n1. Desplácese hasta 'Navegador web'\n2. Haga clic en el navegador actual\n3. Seleccione 'BrowserSelector' de la lista"
    IDS_VERIFY_TITLE            "Verificación"
    IDS_VERIFY_MSG              "La Configuración de Windows se ha abierto para selección manual.\n\nDespués de seleccionar Browser Selector, haga clic en 'Sí' para verificar.\n\n¿Ha completado la selección?"
    IDS_NOW_DEFAULT_MSG         "¡Browser Selector es ahora su navegador predeterminado!"
    IDS_NOT_DEFAULT_MSG         "Browser Selector aún no está establecido por defecto.\n\nPor favor, seleccione 'BrowserSelector' en la Configuración de Windows."
END

STRINGTABLE
BEGIN
    // Main application messages
    IDS_CONFIG_LOAD_FAILED      "Error al cargar la configuración"
    IDS_CONFIG_LOAD_FAILED_MSG  "Error al cargar la configuración."
    IDS_CONFIG_CREATE_FAILED    "Error al crear la configuración predeterminada."
    IDS_CONFIG_LOAD_RETRY_FAIL  "Error al cargar la configuración después de crearla."
    IDS_NO_BROWSERS_TITLE       "Sin navegadores"
    IDS_NO_BROWSERS_MSG         "No hay navegadores configurados.\n\nSe abrirá la ventana de configuración para añadir navegadores."
    IDS_WINDOW_CREATE_FAILED    "Error al crear la ventana principal."
    IDS_CONFIG_CORRUPTED_MSG    "El archivo de configuración está dañado y no se puede leer.\n\n¿Crear nueva configuración predeterminada?"
    IDS_CONFIG_CREATE_BTN       "Crear config"
    IDS_CONFIG_EXIT_BTN         "Salir"
END


// ============================================================================
// ITALIAN - LANG_ITALIAN, SUBLANG_DEFAULT
// ============================================================================
LANGUAGE LANG_ITALIAN, SUBLANG_DEFAULT
#pragma code_page(65001)

STRINGTABLE
BEGIN
    // Main window
    IDS_APP_TITLE               "Selettore browser"
    IDS_SETTINGS_BTN            "Impostazioni"
    IDS_SET_DEFAULT_BTN         "Imposta predefinito"
    IDS_UNREGISTER_BTN          "Annulla registrazione"
    IDS_COUNTDOWN_SECONDS       "Apertura browser predefinito tra %d secondi..."
    IDS_COUNTDOWN_SECOND        "Apertura browser predefinito tra 1 secondo..."
    IDS_COUNTDOWN_NOW           "Apertura browser predefinito..."
END

STRINGTABLE
BEGIN
    // Settings window
    IDS_SETTINGS_TITLE          "Impostazioni - Selettore browser"
    IDS_ADD_BTN                 "Aggiungi"
    IDS_EDIT_BTN                "Modifica"
    IDS_DELETE_BTN              "Elimina"
    IDS_MOVE_UP_BTN             "Sposta su"
    IDS_MOVE_DOWN_BTN           "Sposta giù"
    IDS_SET_DEFAULT_CMD_BTN     "Predefinito"
    IDS_CLOSE_BTN               "Chiudi"
    IDS_WAITTIME_LABEL          "Tempo di attesa (1-10 sec):"
    IDS_DEFAULT_MARKER          "[predefinito]"
    IDS_MAX_COMMANDS_WARNING    "Numero massimo di comandi raggiunto"
    IDS_CONFIRM_DELETE_TITLE    "Conferma eliminazione"
    IDS_CONFIRM_DELETE_MSG      "Eliminare '%s'?"
END

STRINGTABLE
BEGIN
    // Command editor
    IDS_ADD_BROWSER_TITLE       "Aggiungi browser"
    IDS_EDIT_BROWSER_TITLE      "Modifica browser"
    IDS_NAME_LABEL              "Nome:"
    IDS_COMMAND_LABEL           "Comando:"
    IDS_URL_PLACEHOLDER_HINT    "Usa {url} per URL. Esempio: chrome.exe {url}"
    IDS_OK_BTN                  "OK"
    IDS_CANCEL_BTN              "Annulla"
    IDS_BROWSE_TITLE            "Seleziona eseguibile del browser"
    IDS_BROWSE_FILTER_EXE       "File eseguibili (*.exe)"
    IDS_BROWSE_FILTER_ALL       "Tutti i file (*.*)"
    IDS_VALIDATION_NAME_EMPTY   "Il nome non può essere vuoto"
    IDS_VALIDATION_CMD_EMPTY    "Il comando non può essere vuoto"
    IDS_VALIDATION_ERROR_TITLE  "Errore di validazione"
END

STRINGTABLE
BEGIN
    // Error messages
    IDS_ERROR                   "Errore"
    IDS_WARNING                 "Avviso"
    IDS_SUCCESS                 "Successo"
    IDS_CMD_NOT_FOUND           "Comando non trovato: %s"
    IDS_CMD_NOT_FOUND_HINT      "Assicurati che il programma sia installato e nel PATH, o usa un percorso assoluto."
    IDS_LAUNCH_FAILED           "Avvio fallito: %s\nCodice errore: %lu"
    IDS_MEMORY_ERROR            "Allocazione memoria fallita"
END

STRINGTABLE
BEGIN
    // Registration messages
    IDS_REG_SUCCESS_TITLE       "Registrazione riuscita"
    IDS_REG_SUCCESS_MSG         "Browser Selector è stato impostato come browser predefinito!\n\nTutti i link web si apriranno tramite Browser Selector."
    IDS_REG_FAILED_TITLE        "Registrazione fallita"
    IDS_REG_FAILED_MSG          "Impossibile registrare Browser Selector.\n\nProva ad eseguire come amministratore."
    IDS_UNREG_SUCCESS_TITLE     "Annullamento registrazione riuscito"
    IDS_UNREG_SUCCESS_MSG       "Browser Selector è stato rimosso.\n\nNon apparirà più nell'elenco dei browser disponibili."
    IDS_UNREG_FAILED_TITLE      "Annullamento fallito"
    IDS_UNREG_FAILED_MSG        "Impossibile annullare la registrazione di Browser Selector.\n\nControlla i permessi e riprova."
    IDS_SET_DEFAULT_TITLE       "Imposta come browser predefinito"
    IDS_SET_DEFAULT_MSG         "Seleziona Browser Selector come browser predefinito.\n\nPassaggi nelle Impostazioni Windows:\n1. Scorri fino a 'Browser web'\n2. Clicca sul browser attuale\n3. Seleziona 'BrowserSelector' dalla lista"
    IDS_VERIFY_TITLE            "Verifica"
    IDS_VERIFY_MSG              "Le Impostazioni Windows sono state aperte per la selezione manuale.\n\nDopo aver selezionato Browser Selector, clicca 'Sì' per verificare.\n\nHai completato la selezione?"
    IDS_NOW_DEFAULT_MSG         "Browser Selector è ora il tuo browser predefinito!"
    IDS_NOT_DEFAULT_MSG         "Browser Selector non è ancora impostato come predefinito.\n\nSeleziona 'BrowserSelector' nelle Impostazioni Windows."
END

STRINGTABLE
BEGIN
    // Main application messages
    IDS_CONFIG_LOAD_FAILED      "Caricamento configurazione fallito"
    IDS_CONFIG_LOAD_FAILED_MSG  "Caricamento configurazione fallito."
    IDS_CONFIG_CREATE_FAILED    "Creazione configurazione predefinita fallita."
    IDS_CONFIG_LOAD_RETRY_FAIL  "Caricamento configurazione fallito dopo la creazione."
    IDS_NO_BROWSERS_TITLE       "Nessun browser"
    IDS_NO_BROWSERS_MSG         "Nessun browser configurato.\n\nSi aprirà la finestra impostazioni per aggiungere browser."
    IDS_WINDOW_CREATE_FAILED    "Creazione finestra principale fallita."
    IDS_CONFIG_CORRUPTED_MSG    "Il file di configurazione è danneggiato e non può essere letto.\n\nCreare nuova configurazione predefinita?"
    IDS_CONFIG_CREATE_BTN       "Crea config"
    IDS_CONFIG_EXIT_BTN         "Esci"
END


// ============================================================================
// POLISH - LANG_POLISH, SUBLANG_DEFAULT
// ============================================================================
LANGUAGE LANG_POLISH, SUBLANG_DEFAULT
#pragma code_page(65001)

STRINGTABLE
BEGIN
    // Main window
    IDS_APP_TITLE               "Wybór przeglądarki"
    IDS_SETTINGS_BTN            "Ustawienia"
    IDS_SET_DEFAULT_BTN         "Ustaw jako domyślną"
    IDS_UNREGISTER_BTN          "Wyrejestruj"
    IDS_COUNTDOWN_SECONDS       "Otwarcie domyślnej przeglądarki za %d sekund..."
    IDS_COUNTDOWN_SECOND        "Otwarcie domyślnej przeglądarki za 1 sekundę..."
    IDS_COUNTDOWN_NOW           "Otwieranie domyślnej przeglądarki..."
END

STRINGTABLE
BEGIN
    // Settings window
    IDS_SETTINGS_TITLE          "Ustawienia - Wybór przeglądarki"
    IDS_ADD_BTN                 "Dodaj"
    IDS_EDIT_BTN                "Edytuj"
    IDS_DELETE_BTN              "Usuń"
    IDS_MOVE_UP_BTN             "W górę"
    IDS_MOVE_DOWN_BTN           "W dół"
    IDS_SET_DEFAULT_CMD_BTN     "Domyślna"
    IDS_CLOSE_BTN               "Zamknij"
    IDS_WAITTIME_LABEL          "Czas oczekiwania (1-10 sek):"
    IDS_DEFAULT_MARKER          "[domyślna]"
    IDS_MAX_COMMANDS_WARNING    "Osiągnięto maksymalną liczbę poleceń"
    IDS_CONFIRM_DELETE_TITLE    "Potwierdź usunięcie"
    IDS_CONFIRM_DELETE_MSG      "Usunąć '%s'?"
END

STRINGTABLE
BEGIN
    // Command editor
    IDS_ADD_BROWSER_TITLE       "Dodaj przeglądarkę"
    IDS_EDIT_BROWSER_TITLE      "Edytuj przeglądarkę"
    IDS_NAME_LABEL              "Nazwa:"
    IDS_COMMAND_LABEL           "Polecenie:"
    IDS_URL_PLACEHOLDER_HINT    "Użyj {url} dla URL. Przykład: chrome.exe {url}"
    IDS_OK_BTN                  "OK"
    IDS_CANCEL_BTN              "Anuluj"
    IDS_BROWSE_TITLE            "Wybierz plik wykonywalny przeglądarki"
    IDS_BROWSE_FILTER_EXE       "Pliki wykonywalne (*.exe)"
    IDS_BROWSE_FILTER_ALL       "Wszystkie pliki (*.*)"
    IDS_VALIDATION_NAME_EMPTY   "Nazwa nie może być pusta"
    IDS_VALIDATION_CMD_EMPTY    "Polecenie nie może być puste"
    IDS_VALIDATION_ERROR_TITLE  "Błąd walidacji"
END

STRINGTABLE
BEGIN
    // Error messages
    IDS_ERROR                   "Błąd"
    IDS_WARNING                 "Ostrzeżenie"
    IDS_SUCCESS                 "Sukces"
    IDS_CMD_NOT_FOUND           "Nie znaleziono polecenia: %s"
    IDS_CMD_NOT_FOUND_HINT      "Upewnij się, że program jest zainstalowany i w PATH, lub użyj ścieżki bezwzględnej."
    IDS_LAUNCH_FAILED           "Uruchomienie nie powiodło się: %s\nKod błędu: %lu"
    IDS_MEMORY_ERROR            "Nie udało się przydzielić pamięci"
END

STRINGTABLE
BEGIN
    // Registration messages
    IDS_REG_SUCCESS_TITLE       "Rejestracja udana"
    IDS_REG_SUCCESS_MSG         "Browser Selector został ustawiony jako domyślna przeglądarka!\n\nWszystkie linki będą otwierane przez Browser Selector."
    IDS_REG_FAILED_TITLE        "Rejestracja nie powiodła się"
    IDS_REG_FAILED_MSG          "Nie udało się zarejestrować Browser Selector.\n\nSpróbuj uruchomić jako administrator."
    IDS_UNREG_SUCCESS_TITLE     "Wyrejestrowanie udane"
    IDS_UNREG_SUCCESS_MSG       "Browser Selector został wyrejestrowany.\n\nNie będzie już widoczny na liście dostępnych przeglądarek."
    IDS_UNREG_FAILED_TITLE      "Wyrejestrowanie nie powiodło się"
    IDS_UNREG_FAILED_MSG        "Nie udało się wyrejestrować Browser Selector.\n\nSprawdź uprawnienia i spróbuj ponownie."
    IDS_SET_DEFAULT_TITLE       "Ustaw jako domyślną przeglądarkę"
    IDS_SET_DEFAULT_MSG         "Wybierz Browser Selector jako domyślną przeglądarkę.\n\nKroki w Ustawieniach Windows:\n1. Przewiń do 'Przeglądarka internetowa'\n2. Kliknij bieżącą przeglądarkę\n3. Wybierz 'BrowserSelector' z listy"
    IDS_VERIFY_TITLE            "Weryfikacja"
    IDS_VERIFY_MSG              "Ustawienia Windows zostały otwarte do ręcznego wyboru.\n\nPo wybraniu Browser Selector kliknij 'Tak' aby zweryfikować.\n\nCzy zakończyłeś wybór?"
    IDS_NOW_DEFAULT_MSG         "Browser Selector jest teraz Twoją domyślną przeglądarką!"
    IDS_NOT_DEFAULT_MSG         "Browser Selector nie jest jeszcze ustawiony jako domyślny.\n\nWybierz 'BrowserSelector' w Ustawieniach Windows."
END

STRINGTABLE
BEGIN
    // Main application messages
    IDS_CONFIG_LOAD_FAILED      "Nie udało się wczytać konfiguracji"
    IDS_CONFIG_LOAD_FAILED_MSG  "Nie udało się wczytać konfiguracji."
    IDS_CONFIG_CREATE_FAILED    "Nie udało się utworzyć domyślnej konfiguracji."
    IDS_CONFIG_LOAD_RETRY_FAIL  "Nie udało się wczytać konfiguracji po utworzeniu."
    IDS_NO_BROWSERS_TITLE       "Brak przeglądarek"
    IDS_NO_BROWSERS_MSG         "Nie skonfigurowano przeglądarek.\n\nOkno ustawień otworzy się aby dodać przeglądarki."
    IDS_WINDOW_CREATE_FAILED    "Nie udało się utworzyć głównego okna."
    IDS_CONFIG_CORRUPTED_MSG    "Plik konfiguracji jest uszkodzony i nie można go odczytać.\n\nUtwórzyć nową domyślną konfigurację?"
    IDS_CONFIG_CREATE_BTN       "Utwórz konfig"
    IDS_CONFIG_EXIT_BTN         "Wyjdź"
END


// ============================================================================
// DUTCH - LANG_DUTCH, SUBLANG_DEFAULT
// ============================================================================
LANGUAGE LANG_DUTCH, SUBLANG_DEFAULT
#pragma code_page(65001)

STRINGTABLE
BEGIN
    // Main window
    IDS_APP_TITLE               "Browser Kiezer"
    IDS_SETTINGS_BTN            "Instellingen"
    IDS_SET_DEFAULT_BTN         "Als standaard instellen"
    IDS_UNREGISTER_BTN          "Registratie opheffen"
    IDS_COUNTDOWN_SECONDS       "Standaardbrowser openen over %d seconden..."
    IDS_COUNTDOWN_SECOND        "Standaardbrowser openen over 1 seconde..."
    IDS_COUNTDOWN_NOW           "Standaardbrowser wordt geopend..."
END

STRINGTABLE
BEGIN
    // Settings window
    IDS_SETTINGS_TITLE          "Instellingen - Browser Kiezer"
    IDS_ADD_BTN                 "Toevoegen"
    IDS_EDIT_BTN                "Bewerken"
    IDS_DELETE_BTN              "Verwijderen"
    IDS_MOVE_UP_BTN             "Omhoog"
    IDS_MOVE_DOWN_BTN           "Omlaag"
    IDS_SET_DEFAULT_CMD_BTN     "Standaard"
    IDS_CLOSE_BTN               "Sluiten"
    IDS_WAITTIME_LABEL          "Wachttijd (1-10 sec):"
    IDS_DEFAULT_MARKER          "[standaard]"
    IDS_MAX_COMMANDS_WARNING    "Maximum aantal opdrachten bereikt"
    IDS_CONFIRM_DELETE_TITLE    "Verwijderen bevestigen"
    IDS_CONFIRM_DELETE_MSG      "'%s' verwijderen?"
END

STRINGTABLE
BEGIN
    // Command editor
    IDS_ADD_BROWSER_TITLE       "Browser toevoegen"
    IDS_EDIT_BROWSER_TITLE      "Browser bewerken"
    IDS_NAME_LABEL              "Naam:"
    IDS_COMMAND_LABEL           "Opdracht:"
    IDS_URL_PLACEHOLDER_HINT    "Gebruik {url} voor URL. Voorbeeld: chrome.exe {url}"
    IDS_OK_BTN                  "OK"
    IDS_CANCEL_BTN              "Annuleren"
    IDS_BROWSE_TITLE            "Browser-uitvoerbestand selecteren"
    IDS_BROWSE_FILTER_EXE       "Uitvoerbare bestanden (*.exe)"
    IDS_BROWSE_FILTER_ALL       "Alle bestanden (*.*)"
    IDS_VALIDATION_NAME_EMPTY   "Naam mag niet leeg zijn"
    IDS_VALIDATION_CMD_EMPTY    "Opdracht mag niet leeg zijn"
    IDS_VALIDATION_ERROR_TITLE  "Validatiefout"
END

STRINGTABLE
BEGIN
    // Error messages
    IDS_ERROR                   "Fout"
    IDS_WARNING                 "Waarschuwing"
    IDS_SUCCESS                 "Succes"
    IDS_CMD_NOT_FOUND           "Opdracht niet gevonden: %s"
    IDS_CMD_NOT_FOUND_HINT      "Zorg ervoor dat het programma is geïnstalleerd en in het PATH staat, of gebruik een absoluut pad."
    IDS_LAUNCH_FAILED           "Starten mislukt: %s\nFoutcode: %lu"
    IDS_MEMORY_ERROR            "Geheugentoewijzing mislukt"
END

STRINGTABLE
BEGIN
    // Registration messages
    IDS_REG_SUCCESS_TITLE       "Registratie geslaagd"
    IDS_REG_SUCCESS_MSG         "Browser Selector is ingesteld als uw standaardbrowser!\n\nAlle weblinks worden nu geopend via Browser Selector."
    IDS_REG_FAILED_TITLE        "Registratie mislukt"
    IDS_REG_FAILED_MSG          "Kan Browser Selector niet registreren.\n\nProbeer als administrator uit te voeren."
    IDS_UNREG_SUCCESS_TITLE     "Registratie opgeheven"
    IDS_UNREG_SUCCESS_MSG       "Browser Selector is uitgeschreven.\n\nHet verschijnt niet meer in de lijst met beschikbare browsers."
    IDS_UNREG_FAILED_TITLE      "Opheffen mislukt"
    IDS_UNREG_FAILED_MSG        "Kan registratie van Browser Selector niet opheffen.\n\nControleer de machtigingen en probeer opnieuw."
    IDS_SET_DEFAULT_TITLE       "Als standaardbrowser instellen"
    IDS_SET_DEFAULT_MSG         "Selecteer Browser Selector als uw standaardbrowser.\n\nStappen in Windows-instellingen:\n1. Scroll naar 'Webbrowser'\n2. Klik op de huidige browser\n3. Selecteer 'BrowserSelector' uit de lijst"
    IDS_VERIFY_TITLE            "Verificatie"
    IDS_VERIFY_MSG              "Windows-instellingen zijn geopend voor handmatige selectie.\n\nNa het selecteren van Browser Selector, klik op 'Ja' om te verifiëren.\n\nHeeft u de selectie voltooid?"
    IDS_NOW_DEFAULT_MSG         "Browser Selector is nu uw standaardbrowser!"
    IDS_NOT_DEFAULT_MSG         "Browser Selector is nog niet als standaard ingesteld.\n\nSelecteer 'BrowserSelector' in Windows-instellingen."
END

STRINGTABLE
BEGIN
    // Main application messages
    IDS_CONFIG_LOAD_FAILED      "Configuratie laden mislukt"
    IDS_CONFIG_LOAD_FAILED_MSG  "Configuratie laden mislukt."
    IDS_CONFIG_CREATE_FAILED    "Standaardconfiguratie aanmaken mislukt."
    IDS_CONFIG_LOAD_RETRY_FAIL  "Configuratie laden mislukt na aanmaken."
    IDS_NO_BROWSERS_TITLE       "Geen browsers"
    IDS_NO_BROWSERS_MSG         "Geen browsers geconfigureerd.\n\nHet instellingenvenster wordt geopend om browsers toe te voegen."
    IDS_WINDOW_CREATE_FAILED    "Hoofdvenster aanmaken mislukt."
    IDS_CONFIG_CORRUPTED_MSG    "Configuratiebestand is beschadigd en kan niet worden gelezen.\n\nNieuwe standaardconfiguratie aanmaken?"
    IDS_CONFIG_CREATE_BTN       "Config aanmaken"
    IDS_CONFIG_EXIT_BTN         "Afsluiten"
END


// ============================================================================
// PORTUGUESE - LANG_PORTUGUESE, SUBLANG_DEFAULT
// ============================================================================
LANGUAGE LANG_PORTUGUESE, SUBLANG_DEFAULT
#pragma code_page(65001)

STRINGTABLE
BEGIN
    // Main window
    IDS_APP_TITLE               "Seletor de Navegador"
    IDS_SETTINGS_BTN            "Configurações"
    IDS_SET_DEFAULT_BTN         "Definir como padrão"
    IDS_UNREGISTER_BTN          "Cancelar registro"
    IDS_COUNTDOWN_SECONDS       "Abrindo navegador padrão em %d segundos..."
    IDS_COUNTDOWN_SECOND        "Abrindo navegador padrão em 1 segundo..."
    IDS_COUNTDOWN_NOW           "Abrindo navegador padrão..."
END

STRINGTABLE
BEGIN
    // Settings window
    IDS_SETTINGS_TITLE          "Configurações - Seletor de Navegador"
    IDS_ADD_BTN                 "Adicionar"
    IDS_EDIT_BTN                "Editar"
    IDS_DELETE_BTN              "Excluir"
    IDS_MOVE_UP_BTN             "Mover acima"
    IDS_MOVE_DOWN_BTN           "Mover abaixo"
    IDS_SET_DEFAULT_CMD_BTN     "Padrão"
    IDS_CLOSE_BTN               "Fechar"
    IDS_WAITTIME_LABEL          "Tempo de espera (1-10 seg):"
    IDS_DEFAULT_MARKER          "[padrão]"
    IDS_MAX_COMMANDS_WARNING    "Número máximo de comandos atingido"
    IDS_CONFIRM_DELETE_TITLE    "Confirmar exclusão"
    IDS_CONFIRM_DELETE_MSG      "Excluir '%s'?"
END

STRINGTABLE
BEGIN
    // Command editor
    IDS_ADD_BROWSER_TITLE       "Adicionar navegador"
    IDS_EDIT_BROWSER_TITLE      "Editar navegador"
    IDS_NAME_LABEL              "Nome:"
    IDS_COMMAND_LABEL           "Comando:"
    IDS_URL_PLACEHOLDER_HINT    "Use {url} para URL. Exemplo: chrome.exe {url}"
    IDS_OK_BTN                  "OK"
    IDS_CANCEL_BTN              "Cancelar"
    IDS_BROWSE_TITLE            "Selecionar executável do navegador"
    IDS_BROWSE_FILTER_EXE       "Arquivos executáveis (*.exe)"
    IDS_BROWSE_FILTER_ALL       "Todos os arquivos (*.*)"
    IDS_VALIDATION_NAME_EMPTY   "O nome não pode estar vazio"
    IDS_VALIDATION_CMD_EMPTY    "O comando não pode estar vazio"
    IDS_VALIDATION_ERROR_TITLE  "Erro de validação"
END

STRINGTABLE
BEGIN
    // Error messages
    IDS_ERROR                   "Erro"
    IDS_WARNING                 "Aviso"
    IDS_SUCCESS                 "Sucesso"
    IDS_CMD_NOT_FOUND           "Comando não encontrado: %s"
    IDS_CMD_NOT_FOUND_HINT      "Certifique-se de que o programa está instalado e no PATH, ou use um caminho absoluto."
    IDS_LAUNCH_FAILED           "Falha ao iniciar: %s\nCódigo de erro: %lu"
    IDS_MEMORY_ERROR            "Falha na alocação de memória"
END

STRINGTABLE
BEGIN
    // Registration messages
    IDS_REG_SUCCESS_TITLE       "Registro bem-sucedido"
    IDS_REG_SUCCESS_MSG         "Browser Selector foi definido como seu navegador padrão!\n\nTodos os links serão abertos através do Browser Selector."
    IDS_REG_FAILED_TITLE        "Falha no registro"
    IDS_REG_FAILED_MSG          "Não foi possível registrar o Browser Selector.\n\nTente executar como administrador."
    IDS_UNREG_SUCCESS_TITLE     "Cancelamento de registro bem-sucedido"
    IDS_UNREG_SUCCESS_MSG       "Browser Selector foi removido.\n\nEle não aparecerá mais na lista de navegadores disponíveis."
    IDS_UNREG_FAILED_TITLE      "Falha no cancelamento"
    IDS_UNREG_FAILED_MSG        "Não foi possível cancelar o registro do Browser Selector.\n\nVerifique as permissões e tente novamente."
    IDS_SET_DEFAULT_TITLE       "Definir como navegador padrão"
    IDS_SET_DEFAULT_MSG         "Selecione Browser Selector como seu navegador padrão.\n\nPassos nas Configurações do Windows:\n1. Role até 'Navegador da web'\n2. Clique no navegador atual\n3. Selecione 'BrowserSelector' da lista"
    IDS_VERIFY_TITLE            "Verificação"
    IDS_VERIFY_MSG              "As Configurações do Windows foram abertas para seleção manual.\n\nApós selecionar Browser Selector, clique em 'Sim' para verificar.\n\nVocê completou a seleção?"
    IDS_NOW_DEFAULT_MSG         "Browser Selector agora é seu navegador padrão!"
    IDS_NOT_DEFAULT_MSG         "Browser Selector ainda não está definido como padrão.\n\nSelecione 'BrowserSelector' nas Configurações do Windows."
END

STRINGTABLE
BEGIN
    // Main application messages
    IDS_CONFIG_LOAD_FAILED      "Falha ao carregar configuração"
    IDS_CONFIG_LOAD_FAILED_MSG  "Falha ao carregar configuração."
    IDS_CONFIG_CREATE_FAILED    "Falha ao criar configuração padrão."
    IDS_CONFIG_LOAD_RETRY_FAIL  "Falha ao carregar configuração após criação."
    IDS_NO_BROWSERS_TITLE       "Sem navegadores"
    IDS_NO_BROWSERS_MSG         "Nenhum navegador configurado.\n\nA janela de configurações será aberta para adicionar navegadores."
    IDS_WINDOW_CREATE_FAILED    "Falha ao criar janela principal."
    IDS_CONFIG_CORRUPTED_MSG    "Arquivo de configuração está corrompido e não pode ser lido.\n\nCriar nova configuração padrão?"
    IDS_CONFIG_CREATE_BTN       "Criar config"
    IDS_CONFIG_EXIT_BTN         "Sair"
END

```

// FILE: src/config/config.c
```
#include "config.h"
#include "../../include/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

void GetConfigPath(const char* exePath, char* configPath) {
    strcpy(configPath, exePath);
    char* lastSlash = strrchr(configPath, '\\');
    if (lastSlash) {
        *(lastSlash + 1) = '\0';
        strcat(configPath, "config.json");
    }
}

int CreateDefaultConfig(const char* configPath) {
    // Create JSON object
    cJSON* json = cJSON_CreateObject();
    
    // Add settings
    cJSON* settings = cJSON_CreateObject();
    cJSON_AddNumberToObject(settings, "defaultCommandIndex", 3);  // Helium as default
    cJSON_AddNumberToObject(settings, "waitTime", 10);
    cJSON_AddItemToObject(json, "settings", settings);
    
    // Add default commands
    cJSON* commands = cJSON_CreateArray();
    
    // Copy to Clipboard (default)
    cJSON* clipboard = cJSON_CreateObject();
    cJSON_AddStringToObject(clipboard, "name", "Copy to Clipboard");
    cJSON_AddStringToObject(clipboard, "command", "echo {url} | clip");
    cJSON_AddItemToArray(commands, clipboard);

    // Chrome Incognito
    cJSON* chrome = cJSON_CreateObject();
    cJSON_AddStringToObject(chrome, "name", "Chrome Incognito");
    cJSON_AddStringToObject(chrome, "command", "chrome.exe --incognito {url}");
    cJSON_AddItemToArray(commands, chrome);

    // Firefox with profile
    cJSON* firefox = cJSON_CreateObject();
    cJSON_AddStringToObject(firefox, "name", "Firefox Profile");
    cJSON_AddStringToObject(firefox, "command", "firefox.exe -P default {url}");
    cJSON_AddItemToArray(commands, firefox);
    
    // Helium
    cJSON* helium = cJSON_CreateObject();
    cJSON_AddStringToObject(helium, "name", "Helium");
    cJSON_AddStringToObject(helium, "command", "helium.exe {url}");
    cJSON_AddItemToArray(commands, helium);
    
    cJSON_AddItemToObject(json, "commands", commands);
    
    // Write to file
    char* jsonString = cJSON_Print(json);
    FILE* file = fopen(configPath, "w");
    int success = 0;
    if (file) {
        fputs(jsonString, file);
        fclose(file);
        success = 1;
    }
    
    cJSON_free(jsonString);
    cJSON_Delete(json);
    
    return success;
}

int LoadConfig(const char* exePath, Configuration* config) {
    // Get config.json path
    char configPath[MAX_PATH];
    GetConfigPath(exePath, configPath);
    
    // Try to open file
    FILE* file = fopen(configPath, "r");
    if (!file) {
        // File doesn't exist - silently create default configuration
        if (CreateDefaultConfig(configPath)) {
            file = fopen(configPath, "r");
            if (!file) return CONFIG_READ_ERROR;
        } else {
            return CONFIG_READ_ERROR;
        }
    }
    
    // Read file
    fseek(file, 0, SEEK_END);
    long fileSize = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    char* jsonString = (char*)malloc(fileSize + 1);
    if (!jsonString) {
        fclose(file);
        return CONFIG_MEMORY_ERROR;
    }
    
    size_t bytesRead = fread(jsonString, 1, fileSize, file);
    jsonString[bytesRead] = '\0';
    fclose(file);
    
    // Parse JSON
    cJSON* json = cJSON_Parse(jsonString);
    free(jsonString);
    
    if (!json) {
        return CONFIG_PARSE_ERROR;
    }
    
    // Initialize defaults
    config->settings.defaultCommandIndex = 0;
    config->settings.waitTime = 10;
    config->commandCount = 0;
    
    // Read settings
    cJSON* settings = cJSON_GetObjectItem(json, "settings");
    if (settings) {
        cJSON* defaultIndex = cJSON_GetObjectItem(settings, "defaultCommandIndex");
        cJSON* waitTime = cJSON_GetObjectItem(settings, "waitTime");
        
        if (defaultIndex && cJSON_IsNumber(defaultIndex)) {
            config->settings.defaultCommandIndex = defaultIndex->valueint;
        }
        
        if (waitTime && cJSON_IsNumber(waitTime)) {
            config->settings.waitTime = waitTime->valueint;
        }
    }
    
    // Read commands
    cJSON* commands = cJSON_GetObjectItem(json, "commands");
    if (commands && cJSON_IsArray(commands)) {
        cJSON* command = NULL;
        cJSON_ArrayForEach(command, commands) {
            if (config->commandCount >= MAX_COMMANDS) break;
            
            cJSON* name = cJSON_GetObjectItem(command, "name");
            cJSON* cmd = cJSON_GetObjectItem(command, "command");
            
            if (name && cJSON_IsString(name) && 
                cmd && cJSON_IsString(cmd)) {
                strncpy(config->commands[config->commandCount].name, 
                       name->valuestring, MAX_NAME_LENGTH - 1);
                config->commands[config->commandCount].name[MAX_NAME_LENGTH - 1] = '\0';
                
                strncpy(config->commands[config->commandCount].command, 
                       cmd->valuestring, MAX_COMMAND_LENGTH - 1);
                config->commands[config->commandCount].command[MAX_COMMAND_LENGTH - 1] = '\0';
                
                config->commandCount++;
            }
        }
    }
    
    cJSON_Delete(json);
    
    // Validate defaultCommandIndex
    if (config->settings.defaultCommandIndex >= config->commandCount) {
        config->settings.defaultCommandIndex = 0;
    }
    
    return CONFIG_OK;
}

int SaveConfig(const char* exePath, const Configuration* config) {
    // Get config.json path
    char configPath[MAX_PATH];
    GetConfigPath(exePath, configPath);
    
    // Create JSON object
    cJSON* json = cJSON_CreateObject();
    
    // Add settings
    cJSON* settings = cJSON_CreateObject();
    cJSON_AddNumberToObject(settings, "defaultCommandIndex",
                           config->settings.defaultCommandIndex);
    cJSON_AddNumberToObject(settings, "waitTime",
                           config->settings.waitTime);
    cJSON_AddItemToObject(json, "settings", settings);
    
    // Add commands
    cJSON* commands = cJSON_CreateArray();
    for (int i = 0; i < config->commandCount; i++) {
        cJSON* command = cJSON_CreateObject();
        cJSON_AddStringToObject(command, "name", config->commands[i].name);
        cJSON_AddStringToObject(command, "command", config->commands[i].command);
        cJSON_AddItemToArray(commands, command);
    }
    cJSON_AddItemToObject(json, "commands", commands);
    
    // Write to file
    char* jsonString = cJSON_Print(json);
    FILE* file = fopen(configPath, "w");
    int success = 0;
    if (file) {
        fputs(jsonString, file);
        fclose(file);
        success = 1;
    }
    
    cJSON_free(jsonString);
    cJSON_Delete(json);
    
    return success;
}

```

// FILE: src/config/config.h
```
#ifndef CONFIG_H
#define CONFIG_H

#define MAX_PATH_LENGTH 260
#define MAX_NAME_LENGTH 100
#define MAX_COMMAND_LENGTH 512
#define MAX_COMMANDS 50

// LoadConfig return codes
#define CONFIG_OK               0
#define CONFIG_FILE_NOT_FOUND   1
#define CONFIG_PARSE_ERROR      2
#define CONFIG_READ_ERROR       3
#define CONFIG_MEMORY_ERROR     4

typedef struct {
    char name[MAX_NAME_LENGTH];
    char command[MAX_COMMAND_LENGTH];
} Command;

typedef struct {
    int defaultCommandIndex;
    int waitTime;
} Settings;

typedef struct {
    Settings settings;
    Command commands[MAX_COMMANDS];
    int commandCount;
} Configuration;

// Functions for working with configuration
int LoadConfig(const char* exePath, Configuration* config);
int SaveConfig(const char* exePath, const Configuration* config);
int CreateDefaultConfig(const char* configPath);
void GetConfigPath(const char* exePath, char* configPath);

#endif // CONFIG_H

```

// FILE: src/executor/executor.c
```
#include "executor.h"
#include "../i18n/i18n.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

static char* ReplaceUrlPlaceholder(const char* command, const char* url) {
    if (!url) url = "";
    
    // Find {url} placeholder
    const char* pos = strstr(command, "{url}");
    if (!pos) {
        return _strdup(command);
    }
    
    // Calculate result size
    size_t urlLen = strlen(url);
    size_t cmdLen = strlen(command);
    size_t resultSize = cmdLen - 5 + urlLen + 1;
    
    char* result = (char*)malloc(resultSize);
    if (!result) return NULL;
    
    // Copy part before {url}
    size_t prefixLen = pos - command;
    strncpy(result, command, prefixLen);
    result[prefixLen] = '\0';
    
    // Add URL
    strcat(result, url);
    
    // Add part after {url}
    strcat(result, pos + 5);
    
    return result;
}

int ExecuteCommand(const Command* command, const char* url) {
    // Replace {url} placeholder in the command string
    char* cmdLine = ReplaceUrlPlaceholder(command->command, url);
    if (!cmdLine) {
        MessageBoxW(NULL, I18n_GetStringW(IDS_MEMORY_ERROR), 
                   I18n_GetStringW(IDS_ERROR), MB_OK | MB_ICONERROR);
        return 0;
    }
    
    // Launch process using cmd.exe /c to support shell commands and pipes
    char fullCmd[2048];
    snprintf(fullCmd, sizeof(fullCmd), "cmd.exe /c %s", cmdLine);
    
    // Launch process
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);
    
    BOOL success = CreateProcessA(
        NULL,           // lpApplicationName
        fullCmd,        // lpCommandLine
        NULL,           // lpProcessAttributes
        NULL,           // lpThreadAttributes
        FALSE,          // bInheritHandles
        CREATE_NO_WINDOW,  // dwCreationFlags - hide console window
        NULL,           // lpEnvironment
        NULL,           // lpCurrentDirectory
        &si,            // lpStartupInfo
        &pi             // lpProcessInformation
    );
    
    if (success) {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    } else {
        wchar_t error[1024];
        wchar_t wideCmd[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, command->command, -1, wideCmd, MAX_PATH);
        
        swprintf(error, 1024, I18n_GetStringW(IDS_LAUNCH_FAILED), wideCmd, GetLastError());
        MessageBoxW(NULL, error, I18n_GetStringW(IDS_ERROR), MB_OK | MB_ICONERROR);
    }
    
    free(cmdLine);
    
    return success ? 1 : 0;
}

```

// FILE: src/executor/executor.h
```
#ifndef EXECUTOR_H
#define EXECUTOR_H

#include "../config/config.h"

// Execute a command with URL
int ExecuteCommand(const Command* command, const char* url);

#endif // EXECUTOR_H

```

// FILE: src/i18n/i18n.c
```
#include "i18n.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Module instance handle
static HINSTANCE g_hInstance = NULL;
static LanguageId g_currentLanguage = LANG_ID_ENGLISH;

// Internal buffers for string retrieval
static wchar_t g_wideBuffer[1024];
static char g_ansiBuffer[2048];

// Language names for debugging
static const char* g_languageNames[LANG_COUNT] = {
    "English",
    "Ukrainian",
    "German",
    "French",
    "Spanish",
    "Italian",
    "Polish",
    "Dutch",
    "Portuguese"
};

// Map Windows LANGID to our language enum
static LanguageId MapWindowsLanguage(LANGID langId) {
    WORD primaryLang = PRIMARYLANGID(langId);
    
    switch (primaryLang) {
        case LANG_UKRAINIAN:
            return LANG_ID_UKRAINIAN;
        case LANG_GERMAN:
            return LANG_ID_GERMAN;
        case LANG_FRENCH:
            return LANG_ID_FRENCH;
        case LANG_SPANISH:
            return LANG_ID_SPANISH;
        case LANG_ITALIAN:
            return LANG_ID_ITALIAN;
        case LANG_POLISH:
            return LANG_ID_POLISH;
        case LANG_DUTCH:
            return LANG_ID_DUTCH;
        case LANG_PORTUGUESE:
            return LANG_ID_PORTUGUESE;
        case LANG_ENGLISH:
        default:
            return LANG_ID_ENGLISH;
    }
}

void I18n_Init(HINSTANCE hInstance) {
    g_hInstance = hInstance;
    
    // Get Windows UI language
    LANGID langId = GetUserDefaultUILanguage();
    g_currentLanguage = MapWindowsLanguage(langId);
    
    // Verify that we can load strings for this language
    // Try to load a test string - if it fails, fall back to English
    if (g_currentLanguage != LANG_ID_ENGLISH) {
        // Calculate resource language
        WORD resLang;
        switch (g_currentLanguage) {
            case LANG_ID_UKRAINIAN:
                resLang = MAKELANGID(LANG_UKRAINIAN, SUBLANG_DEFAULT);
                break;
            case LANG_ID_GERMAN:
                resLang = MAKELANGID(LANG_GERMAN, SUBLANG_DEFAULT);
                break;
            case LANG_ID_FRENCH:
                resLang = MAKELANGID(LANG_FRENCH, SUBLANG_DEFAULT);
                break;
            case LANG_ID_SPANISH:
                resLang = MAKELANGID(LANG_SPANISH, SUBLANG_DEFAULT);
                break;
            case LANG_ID_ITALIAN:
                resLang = MAKELANGID(LANG_ITALIAN, SUBLANG_DEFAULT);
                break;
            case LANG_ID_POLISH:
                resLang = MAKELANGID(LANG_POLISH, SUBLANG_DEFAULT);
                break;
            case LANG_ID_DUTCH:
                resLang = MAKELANGID(LANG_DUTCH, SUBLANG_DEFAULT);
                break;
            case LANG_ID_PORTUGUESE:
                resLang = MAKELANGID(LANG_PORTUGUESE, SUBLANG_DEFAULT);
                break;
            default:
                resLang = MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT);
                break;
        }
        
        // Try to load with specific language
        // If it fails, Windows will fall back automatically through resource lookup
        SetThreadUILanguage(resLang);
    }
}

const wchar_t* I18n_GetStringW(UINT stringId) {
    // Clear buffer
    g_wideBuffer[0] = L'\0';
    
    // Load string from resources
    int len = LoadStringW(g_hInstance, stringId, g_wideBuffer, 
                          sizeof(g_wideBuffer) / sizeof(wchar_t));
    
    if (len <= 0) {
        // String not found - return empty string
        g_wideBuffer[0] = L'\0';
    }
    
    return g_wideBuffer;
}

const char* I18n_GetStringA(UINT stringId) {
    // First get wide string
    const wchar_t* wideStr = I18n_GetStringW(stringId);
    
    // Convert to ANSI
    int len = WideCharToMultiByte(CP_ACP, 0, wideStr, -1, 
                                   g_ansiBuffer, sizeof(g_ansiBuffer), 
                                   NULL, NULL);
    
    if (len <= 0) {
        g_ansiBuffer[0] = '\0';
    }
    
    return g_ansiBuffer;
}

LanguageId I18n_GetCurrentLanguage(void) {
    return g_currentLanguage;
}

const char* I18n_GetLanguageName(LanguageId langId) {
    if (langId >= 0 && langId < LANG_COUNT) {
        return g_languageNames[langId];
    }
    return "Unknown";
}

```

// FILE: src/i18n/i18n.h
```
#ifndef I18N_H
#define I18N_H

#include <windows.h>

// String IDs - organized by category
// Range 100-199: Main window strings
#define IDS_APP_TITLE               100
#define IDS_SETTINGS_BTN            101
#define IDS_SET_DEFAULT_BTN         102
#define IDS_UNREGISTER_BTN          103
#define IDS_COUNTDOWN_SECONDS       104
#define IDS_COUNTDOWN_SECOND        105
#define IDS_COUNTDOWN_NOW           106

// Range 200-299: Settings window strings
#define IDS_SETTINGS_TITLE          200
#define IDS_ADD_BTN                 201
#define IDS_EDIT_BTN                202
#define IDS_DELETE_BTN              203
#define IDS_MOVE_UP_BTN             204
#define IDS_MOVE_DOWN_BTN           205
#define IDS_SET_DEFAULT_CMD_BTN     206
#define IDS_CLOSE_BTN               207
#define IDS_WAITTIME_LABEL          208
#define IDS_DEFAULT_MARKER          209
#define IDS_MAX_COMMANDS_WARNING    210
#define IDS_CONFIRM_DELETE_TITLE    211
#define IDS_CONFIRM_DELETE_MSG      212

// Range 300-399: Command editor strings
#define IDS_ADD_BROWSER_TITLE       300
#define IDS_EDIT_BROWSER_TITLE      301
#define IDS_NAME_LABEL              302
#define IDS_COMMAND_LABEL           303
#define IDS_ARGUMENTS_LABEL         304
#define IDS_URL_PLACEHOLDER_HINT    305
#define IDS_OK_BTN                  306
#define IDS_CANCEL_BTN              307
#define IDS_BROWSE_TITLE            308
#define IDS_BROWSE_FILTER_EXE       309
#define IDS_BROWSE_FILTER_ALL       310
#define IDS_VALIDATION_NAME_EMPTY   311
#define IDS_VALIDATION_CMD_EMPTY    312
#define IDS_VALIDATION_ERROR_TITLE  313

// Range 400-499: Error messages
#define IDS_ERROR                   400
#define IDS_WARNING                 401
#define IDS_SUCCESS                 402
#define IDS_CMD_NOT_FOUND           403
#define IDS_CMD_NOT_FOUND_HINT      404
#define IDS_LAUNCH_FAILED           405
#define IDS_MEMORY_ERROR            406

// Range 500-599: Registration messages
#define IDS_REG_SUCCESS_TITLE       500
#define IDS_REG_SUCCESS_MSG         501
#define IDS_REG_FAILED_TITLE        502
#define IDS_REG_FAILED_MSG          503
#define IDS_UNREG_SUCCESS_TITLE     504
#define IDS_UNREG_SUCCESS_MSG       505
#define IDS_UNREG_FAILED_TITLE      506
#define IDS_UNREG_FAILED_MSG        507
#define IDS_SET_DEFAULT_TITLE       508
#define IDS_SET_DEFAULT_MSG         509
#define IDS_VERIFY_TITLE            510
#define IDS_VERIFY_MSG              511
#define IDS_NOW_DEFAULT_MSG         512
#define IDS_NOT_DEFAULT_MSG         513

// Range 600-699: Main application messages
#define IDS_CONFIG_LOAD_FAILED      600
#define IDS_CONFIG_LOAD_FAILED_MSG  601
#define IDS_CONFIG_CREATE_FAILED    602
#define IDS_CONFIG_LOAD_RETRY_FAIL  603
#define IDS_NO_BROWSERS_TITLE       604
#define IDS_NO_BROWSERS_MSG         605
#define IDS_WINDOW_CREATE_FAILED    606
#define IDS_CONFIG_CORRUPTED_MSG    607
#define IDS_CONFIG_CREATE_BTN       608
#define IDS_CONFIG_EXIT_BTN         609

// Supported languages
typedef enum {
    LANG_ID_ENGLISH = 0,
    LANG_ID_UKRAINIAN,
    LANG_ID_GERMAN,
    LANG_ID_FRENCH,
    LANG_ID_SPANISH,
    LANG_ID_ITALIAN,
    LANG_ID_POLISH,
    LANG_ID_DUTCH,
    LANG_ID_PORTUGUESE,
    LANG_COUNT
} LanguageId;

// Initialize i18n system - must be called at application start
void I18n_Init(HINSTANCE hInstance);

// Get localized string by ID
// Returns pointer to internal buffer - valid until next GetString call
const wchar_t* I18n_GetStringW(UINT stringId);

// Get localized string as ANSI (UTF-8 converted to current code page)
// Returns pointer to internal buffer - valid until next GetString call
const char* I18n_GetStringA(UINT stringId);

// Get current language ID
LanguageId I18n_GetCurrentLanguage(void);

// Get language name (for debugging)
const char* I18n_GetLanguageName(LanguageId langId);

#endif // I18N_H

```

// FILE: src/main.c
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <commctrl.h>
#include "config/config.h"
#include "ui/mainwindow.h"
#include "registry/registry.h"
#include "i18n/i18n.h"

// Parse command line to extract URL
static char* ParseCommandLine(LPSTR lpCmdLine) {
    if (!lpCmdLine || strlen(lpCmdLine) == 0) {
        return NULL;
    }
    
    char* url = lpCmdLine;
    
    // Skip leading spaces
    while (*url == ' ') url++;
    
    if (*url == '\0') {
        return NULL;
    }
    
    // Handle quoted string
    if (*url == '"') {
        url++;
        char* end = strchr(url, '"');
        if (end) {
            *end = '\0';
        }
    } else {
        // Find end of argument (space or end of string)
        char* end = strchr(url, ' ');
        if (end) {
            *end = '\0';
        }
    }
    
    return strlen(url) > 0 ? url : NULL;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                   LPSTR lpCmdLine, int nCmdShow) {
    (void)hPrevInstance;  // Unused
    
    // Initialize i18n (must be first to load localized strings)
    I18n_Init(hInstance);
    
    // Initialize common controls
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_WIN95_CLASSES;
    InitCommonControlsEx(&icc);
    
    // Get executable path
    char exePath[MAX_PATH];
    GetModuleFileNameA(NULL, exePath, MAX_PATH);
    
    // Parse command line
    char* arg = ParseCommandLine(lpCmdLine);
    
    // Load configuration
    Configuration config;
    int loadResult = LoadConfig(exePath, &config);
    
    if (loadResult == CONFIG_PARSE_ERROR) {
        // Config file exists but is corrupted - ask user what to do
        int result = MessageBoxW(NULL, 
            I18n_GetStringW(IDS_CONFIG_CORRUPTED_MSG),
            I18n_GetStringW(IDS_ERROR), 
            MB_YESNO | MB_ICONERROR);
        
        if (result == IDYES) {
            // User chose to create new config
            char configPath[MAX_PATH];
            GetConfigPath(exePath, configPath);
            if (!CreateDefaultConfig(configPath)) {
                MessageBoxW(NULL, I18n_GetStringW(IDS_CONFIG_CREATE_FAILED), 
                           I18n_GetStringW(IDS_ERROR), MB_OK | MB_ICONERROR);
                return 1;
            }
            // Try loading again
            loadResult = LoadConfig(exePath, &config);
            if (loadResult != CONFIG_OK) {
                MessageBoxW(NULL, I18n_GetStringW(IDS_CONFIG_LOAD_RETRY_FAIL), 
                           I18n_GetStringW(IDS_ERROR), MB_OK | MB_ICONERROR);
                return 1;
            }
        } else {
            // User chose to exit
            return 1;
        }
    } else if (loadResult != CONFIG_OK) {
        // Other errors (memory, read error, etc.)
        MessageBoxW(NULL, I18n_GetStringW(IDS_CONFIG_LOAD_FAILED_MSG), 
                   I18n_GetStringW(IDS_ERROR), MB_OK | MB_ICONERROR);
        return 1;
    }
    
    // Check if we have any commands
    if (config.commandCount == 0) {
        MessageBoxW(NULL, 
            I18n_GetStringW(IDS_NO_BROWSERS_MSG),
            I18n_GetStringW(IDS_NO_BROWSERS_TITLE), MB_OK | MB_ICONINFORMATION);
    }
    
    // Create main window
    HWND hwnd = CreateMainWindow(hInstance, &config, arg, exePath);
    if (!hwnd) {
        MessageBoxW(NULL, I18n_GetStringW(IDS_WINDOW_CREATE_FAILED), 
                   I18n_GetStringW(IDS_ERROR), MB_OK | MB_ICONERROR);
        return 1;
    }
    
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    
    // Message loop
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return (int)msg.wParam;
}

```

// FILE: src/registry/registry.c
```
#include "registry.h"
#include "../i18n/i18n.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <shlobj.h>
#include <windows.h>

#define APP_NAME "BrowserSelector"
#define APP_DESC "Browser Selector"

static BOOL SetRegistryValue(HKEY hKey, const char* subKey, const char* valueName, const char* value) {
    HKEY hSubKey;
    LONG result = RegCreateKeyExA(hKey, subKey, 0, NULL, 
                                   REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSubKey, NULL);
    if (result != ERROR_SUCCESS) {
        return FALSE;
    }
    
    result = RegSetValueExA(hSubKey, valueName, 0, REG_SZ, 
                           (const BYTE*)value, (DWORD)(strlen(value) + 1));
    RegCloseKey(hSubKey);
    
    return result == ERROR_SUCCESS;
}

static BOOL DeleteRegistryKey(HKEY hKey, const char* subKey) {
    return RegDeleteTreeA(hKey, subKey) == ERROR_SUCCESS;
}

BOOL RegisterAsBrowser(const char* exePath) {
    char command[MAX_PATH + 10];
    snprintf(command, sizeof(command), "\"%s\" \"%%1\"", exePath);
    
    // Register URL protocol handler
    // HKEY_CURRENT_USER\Software\Classes\BrowserSelector
    char keyPath[256];
    
    // Create main key
    snprintf(keyPath, sizeof(keyPath), "Software\\Classes\\%s", APP_NAME);
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, NULL, "URL:" APP_DESC)) {
        return FALSE;
    }
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, "URL Protocol", "")) {
        return FALSE;
    }
    
    // Create shell\open\command
    snprintf(keyPath, sizeof(keyPath), "Software\\Classes\\%s\\shell\\open\\command", APP_NAME);
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, NULL, command)) {
        return FALSE;
    }
    
    // Register for http protocol
    if (!SetRegistryValue(HKEY_CURRENT_USER, "Software\\Classes\\http\\shell\\" APP_NAME, NULL, "Open with " APP_DESC)) {
        return FALSE;
    }
    snprintf(keyPath, sizeof(keyPath), "Software\\Classes\\http\\shell\\%s\\command", APP_NAME);
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, NULL, command)) {
        return FALSE;
    }
    
    // Register for https protocol
    if (!SetRegistryValue(HKEY_CURRENT_USER, "Software\\Classes\\https\\shell\\" APP_NAME, NULL, "Open with " APP_DESC)) {
        return FALSE;
    }
    snprintf(keyPath, sizeof(keyPath), "Software\\Classes\\https\\shell\\%s\\command", APP_NAME);
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, NULL, command)) {
        return FALSE;
    }
    
    // Register application in Registered Applications
    if (!SetRegistryValue(HKEY_CURRENT_USER, 
                         "Software\\RegisteredApplications", 
                         APP_NAME, 
                         "Software\\Clients\\StartMenuInternet\\" APP_NAME "\\Capabilities")) {
        return FALSE;
    }
    
    // Register as StartMenuInternet client
    snprintf(keyPath, sizeof(keyPath), "Software\\Clients\\StartMenuInternet\\%s", APP_NAME);
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, NULL, APP_DESC)) {
        return FALSE;
    }
    
    // Capabilities
    snprintf(keyPath, sizeof(keyPath), "Software\\Clients\\StartMenuInternet\\%s\\Capabilities", APP_NAME);
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, "ApplicationName", APP_DESC)) {
        return FALSE;
    }
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, "ApplicationDescription", "Select which browser to use for opening URLs")) {
        return FALSE;
    }
    
    // URL Associations
    snprintf(keyPath, sizeof(keyPath), "Software\\Clients\\StartMenuInternet\\%s\\Capabilities\\URLAssociations", APP_NAME);
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, "http", APP_NAME)) {
        return FALSE;
    }
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, "https", APP_NAME)) {
        return FALSE;
    }
    
    // Shell open command
    snprintf(keyPath, sizeof(keyPath), "Software\\Clients\\StartMenuInternet\\%s\\shell\\open\\command", APP_NAME);
    if (!SetRegistryValue(HKEY_CURRENT_USER, keyPath, NULL, command)) {
        return FALSE;
    }
    
    // Notify shell of changes
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
    
    return TRUE;
}

BOOL UnregisterAsBrowser(void) {
    char keyPath[256];
    
    // Delete main class registration
    snprintf(keyPath, sizeof(keyPath), "Software\\Classes\\%s", APP_NAME);
    DeleteRegistryKey(HKEY_CURRENT_USER, keyPath);
    
    // Delete http handler
    snprintf(keyPath, sizeof(keyPath), "Software\\Classes\\http\\shell\\%s", APP_NAME);
    DeleteRegistryKey(HKEY_CURRENT_USER, keyPath);
    
    // Delete https handler
    snprintf(keyPath, sizeof(keyPath), "Software\\Classes\\https\\shell\\%s", APP_NAME);
    DeleteRegistryKey(HKEY_CURRENT_USER, keyPath);
    
    // Delete from RegisteredApplications
    HKEY hKey;
    if (RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\RegisteredApplications", 0, KEY_WRITE, &hKey) == ERROR_SUCCESS) {
        RegDeleteValueA(hKey, APP_NAME);
        RegCloseKey(hKey);
    }
    
    // Delete StartMenuInternet client
    snprintf(keyPath, sizeof(keyPath), "Software\\Clients\\StartMenuInternet\\%s", APP_NAME);
    DeleteRegistryKey(HKEY_CURRENT_USER, keyPath);
    
    // Notify shell of changes
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
    
    return TRUE;
}

BOOL IsRegisteredAsBrowser(void) {
    char keyPath[256];
    HKEY hKey;
    
    snprintf(keyPath, sizeof(keyPath), "Software\\Classes\\%s", APP_NAME);
    LONG result = RegOpenKeyExA(HKEY_CURRENT_USER, keyPath, 0, KEY_READ, &hKey);
    
    if (result == ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return TRUE;
    }
    
    return FALSE;
}

BOOL IsDefaultBrowser(void) {
    char currentDefault[256];
    DWORD bufferSize = sizeof(currentDefault);
    HKEY hKey;
    
    // Check http default
    LONG result = RegOpenKeyExA(HKEY_CURRENT_USER, 
                                "Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
                                0, KEY_READ, &hKey);
    
    if (result == ERROR_SUCCESS) {
        result = RegQueryValueExA(hKey, "ProgId", NULL, NULL, 
                                 (LPBYTE)currentDefault, &bufferSize);
        RegCloseKey(hKey);
        
        if (result == ERROR_SUCCESS && strcmp(currentDefault, APP_NAME) == 0) {
            // Check https as well
            bufferSize = sizeof(currentDefault);
            result = RegOpenKeyExA(HKEY_CURRENT_USER,
                                  "Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\https\\UserChoice",
                                  0, KEY_READ, &hKey);
            
            if (result == ERROR_SUCCESS) {
                result = RegQueryValueExA(hKey, "ProgId", NULL, NULL,
                                         (LPBYTE)currentDefault, &bufferSize);
                RegCloseKey(hKey);
                
                if (result == ERROR_SUCCESS && strcmp(currentDefault, APP_NAME) == 0) {
                    return TRUE;
                }
            }
        }
    }
    
    return FALSE;
}

BOOL SetAsDefaultBrowser(void) {
    // Try IApplicationAssociationRegistrationUI for Windows 8+
    // This will trigger the Windows dialog to set default browser
    
    typedef HRESULT (WINAPI *LaunchAdvancedAssociationUIProc)(LPCWSTR);
    
    HMODULE hShell32 = LoadLibraryA("shell32.dll");
    if (hShell32) {
        // Try the undocumented API that shows the protocol selection dialog
        LaunchAdvancedAssociationUIProc pLaunchUI =
            (LaunchAdvancedAssociationUIProc)(uintptr_t)GetProcAddress(hShell32,
                (LPCSTR)MAKEINTRESOURCEA(144)); // Ordinal 144
        
        if (pLaunchUI) {
            // This shows a mini dialog to set default for HTTP/HTTPS
            HRESULT hr = pLaunchUI(L"http");
            FreeLibrary(hShell32);
            
            if (SUCCEEDED(hr)) {
                // Give Windows time to process
                Sleep(500);
                return IsDefaultBrowser();
            }
        }
        FreeLibrary(hShell32);
    }
    
    // Fallback: Open Windows Settings
    MessageBoxW(NULL,
        I18n_GetStringW(IDS_SET_DEFAULT_MSG),
        I18n_GetStringW(IDS_SET_DEFAULT_TITLE),
        MB_OK | MB_ICONINFORMATION);
    
    ShellExecuteA(NULL, "open", "ms-settings:defaultapps", NULL, NULL, SW_SHOW);
    
    return FALSE;
}

```

// FILE: src/registry/registry.h
```
#ifndef REGISTRY_H
#define REGISTRY_H

#include <windows.h>

// Register application as a browser handler
// Returns TRUE on success
BOOL RegisterAsBrowser(const char* exePath);

// Unregister application as a browser handler
// Returns TRUE on success
BOOL UnregisterAsBrowser(void);

// Check if application is registered as browser
BOOL IsRegisteredAsBrowser(void);

// Check if application is the default browser for http/https
BOOL IsDefaultBrowser(void);

// Set application as default browser (requires prior registration)
// Returns TRUE on success
BOOL SetAsDefaultBrowser(void);

#endif // REGISTRY_H

```

// FILE: src/ui/commandeditor.c
```
#include "commandeditor.h"
#include "../i18n/i18n.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ID_NAME_EDIT 2001
#define ID_COMMAND_EDIT 2002
#define ID_OK_BTN 2005
#define ID_CANCEL_BTN 2006

typedef struct {
    Command* command;
    BOOL isNew;
    BOOL saved;
} CommandEditorData;


LRESULT CALLBACK CommandEditorProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    CommandEditorData* data = (CommandEditorData*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (msg) {
        case WM_CREATE: {
            CREATESTRUCT* cs = (CREATESTRUCT*)lParam;
            data = (CommandEditorData*)cs->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)data);
            
            HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            
            // Name label and edit
            HWND label = CreateWindowExW(0, L"STATIC", I18n_GetStringW(IDS_NAME_LABEL),
                WS_CHILD | WS_VISIBLE,
                10, 15, 60, 20, hwnd, NULL, cs->hInstance, NULL);
            SendMessage(label, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            HWND nameEdit = CreateWindowExA(WS_EX_CLIENTEDGE, "EDIT", data->command->name,
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL,
                80, 12, 280, 24, hwnd, (HMENU)ID_NAME_EDIT, cs->hInstance, NULL);
            SendMessage(nameEdit, WM_SETFONT, (WPARAM)hFont, TRUE);
            SendMessage(nameEdit, EM_SETLIMITTEXT, MAX_NAME_LENGTH - 1, 0);
            
            // Command label and edit
            label = CreateWindowExW(0, L"STATIC", I18n_GetStringW(IDS_COMMAND_LABEL),
                WS_CHILD | WS_VISIBLE,
                10, 50, 60, 20, hwnd, NULL, cs->hInstance, NULL);
            SendMessage(label, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            HWND cmdEdit = CreateWindowExA(WS_EX_CLIENTEDGE, "EDIT", data->command->command,
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL,
                80, 47, 280, 24, hwnd, (HMENU)ID_COMMAND_EDIT, cs->hInstance, NULL);
            SendMessage(cmdEdit, WM_SETFONT, (WPARAM)hFont, TRUE);
            SendMessage(cmdEdit, EM_SETLIMITTEXT, MAX_COMMAND_LENGTH - 1, 0);
            
            // Help text
            label = CreateWindowExW(0, L"STATIC", I18n_GetStringW(IDS_URL_PLACEHOLDER_HINT),
                WS_CHILD | WS_VISIBLE,
                80, 75, 280, 20, hwnd, NULL, cs->hInstance, NULL);
            SendMessage(label, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            // OK and Cancel buttons
            HWND okBtn = CreateWindowExW(0, L"BUTTON", I18n_GetStringW(IDS_OK_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_DEFPUSHBUTTON,
                170, 105, 80, 28, hwnd, (HMENU)ID_OK_BTN, cs->hInstance, NULL);
            SendMessage(okBtn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            HWND cancelBtn = CreateWindowExW(0, L"BUTTON", I18n_GetStringW(IDS_CANCEL_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                255, 105, 80, 28, hwnd, (HMENU)ID_CANCEL_BTN, cs->hInstance, NULL);
            SendMessage(cancelBtn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            // Focus on name field
            SetFocus(nameEdit);
            
            return 0;
        }
        
        case WM_COMMAND: {
            if (!data) break;
            
            switch (LOWORD(wParam)) {
                case ID_OK_BTN: {
                    // Validate and save
                    char name[MAX_NAME_LENGTH];
                    char cmd[MAX_COMMAND_LENGTH];
                    
                    GetDlgItemTextA(hwnd, ID_NAME_EDIT, name, MAX_NAME_LENGTH);
                    GetDlgItemTextA(hwnd, ID_COMMAND_EDIT, cmd, MAX_COMMAND_LENGTH);
                    
                    // Trim whitespace
                    char* p = name;
                    while (*p == ' ') p++;
                    if (*p == '\0') {
                        MessageBoxW(hwnd, I18n_GetStringW(IDS_VALIDATION_NAME_EMPTY), 
                                   I18n_GetStringW(IDS_VALIDATION_ERROR_TITLE), MB_OK | MB_ICONWARNING);
                        SetFocus(GetDlgItem(hwnd, ID_NAME_EDIT));
                        return 0;
                    }
                    
                    p = cmd;
                    while (*p == ' ') p++;
                    if (*p == '\0') {
                        MessageBoxW(hwnd, I18n_GetStringW(IDS_VALIDATION_CMD_EMPTY), 
                                   I18n_GetStringW(IDS_VALIDATION_ERROR_TITLE), MB_OK | MB_ICONWARNING);
                        SetFocus(GetDlgItem(hwnd, ID_COMMAND_EDIT));
                        return 0;
                    }
                    
                    // Save data
                    snprintf(data->command->name, MAX_NAME_LENGTH, "%s", name);
                    snprintf(data->command->command, MAX_COMMAND_LENGTH, "%s", cmd);
                    
                    data->saved = TRUE;
                    DestroyWindow(hwnd);
                    return 0;
                }
                
                case ID_CANCEL_BTN:
                    data->saved = FALSE;
                    DestroyWindow(hwnd);
                    return 0;
            }
            break;
        }
        
        case WM_KEYDOWN: {
            if (wParam == VK_ESCAPE) {
                if (data) data->saved = FALSE;
                DestroyWindow(hwnd);
                return 0;
            }
            break;
        }
        
        case WM_CLOSE: {
            if (data) data->saved = FALSE;
            DestroyWindow(hwnd);
            return 0;
        }
        
        case WM_DESTROY: {
            PostQuitMessage(0);
            return 0;
        }
    }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

BOOL ShowCommandEditor(HWND parent, Command* command, BOOL isNew) {
    HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(parent, GWLP_HINSTANCE);
    
    // Register window class
    WNDCLASSEXW wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEXW);
    wc.lpfnWndProc = CommandEditorProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"CommandEditorClass";
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    
    RegisterClassExW(&wc);
    
    // Prepare data
    CommandEditorData data;
    data.command = command;
    data.isNew = isNew;
    data.saved = FALSE;
    
    // Calculate position
    RECT parentRect;
    GetWindowRect(parent, &parentRect);
    int winWidth = 380;
    int winHeight = 180;
    int winX = parentRect.left + (parentRect.right - parentRect.left - winWidth) / 2;
    int winY = parentRect.top + (parentRect.bottom - parentRect.top - winHeight) / 2;
    
    // Create window
    const wchar_t* title = isNew ? I18n_GetStringW(IDS_ADD_BROWSER_TITLE) : I18n_GetStringW(IDS_EDIT_BROWSER_TITLE);
    HWND hwnd = CreateWindowExW(
        WS_EX_DLGMODALFRAME | WS_EX_TOPMOST,
        L"CommandEditorClass",
        title,
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
        winX, winY, winWidth, winHeight,
        parent, NULL, hInstance, &data
    );
    
    if (!hwnd) return FALSE;
    
    // Disable parent window
    EnableWindow(parent, FALSE);
    
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);
    
    // Modal message loop
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!IsDialogMessage(hwnd, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    // Re-enable parent
    EnableWindow(parent, TRUE);
    SetForegroundWindow(parent);
    
    return data.saved;
}

```

// FILE: src/ui/commandeditor.h
```
#ifndef COMMANDEDITOR_H
#define COMMANDEDITOR_H

#include <windows.h>
#include "../config/config.h"

// Show command editor dialog
// If command is NULL, creates a new command
// Returns TRUE if command was saved
BOOL ShowCommandEditor(HWND parent, Command* command, BOOL isNew);

// Command editor window procedure
LRESULT CALLBACK CommandEditorProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#endif // COMMANDEDITOR_H

```

// FILE: src/ui/mainwindow.c
```
#include "mainwindow.h"
#include "settings.h"
#include "../executor/executor.h"
#include "../registry/registry.h"
#include "../i18n/i18n.h"
#include <stdio.h>
#include <stdlib.h>
#include <commctrl.h>

#define ID_LISTBOX 1001
#define ID_REGISTER_BTN 1002
#define ID_SETTINGS_BTN 1003
#define ID_COUNTDOWN_LABEL 1004
#define TIMER_ID 1005

#define MAIN_WINDOW_WIDTH 480  // Increased from 400 to accommodate wider buttons
#define MAIN_WINDOW_HEIGHT 320

static WNDPROC originalListBoxProc = NULL;
static WNDPROC originalRegisterButtonProc = NULL;
static WNDPROC originalSettingsButtonProc = NULL;

// Forward declarations for timer functions
static void StartTimer(MainWindow* mainWin);
static void StopTimer(MainWindow* mainWin);
static void UpdateCountdownDisplay(MainWindow* mainWin);
static void ExecuteDefaultCommand(MainWindow* mainWin);

// Subclass procedure for Settings button to intercept Tab key
LRESULT CALLBACK ButtonSubclassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    MainWindow* mainWin = (MainWindow*)GetWindowLongPtr(GetParent(hwnd), GWLP_USERDATA);

    if (msg == WM_KEYDOWN && mainWin) {
        // Stop timer on any key press
        if (mainWin->timerActive) {
            StopTimer(mainWin);
        }
        
        if (wParam == VK_TAB) {
            BOOL shift = (GetKeyState(VK_SHIFT) & 0x8000) != 0;

            // Tab cycle: ListBox -> Register -> Settings -> ListBox
            if (hwnd == mainWin->registerBtn) {
                if (shift) {
                    SetFocus(mainWin->listBox);
                } else {
                    SetFocus(mainWin->settingsBtn);
                }
            } else if (hwnd == mainWin->settingsBtn) {
                if (shift) {
                    SetFocus(mainWin->registerBtn);
                } else {
                    SetFocus(mainWin->listBox);
                }
            } else {
                // Fallback: send focus to list
                SetFocus(mainWin->listBox);
            }

            return 0;
        }

        if (wParam == VK_RETURN) {
            // Enter - activate the button
            SendMessage(GetParent(hwnd), WM_COMMAND,
                       (WPARAM)GetWindowLongPtr(hwnd, GWLP_ID), (LPARAM)hwnd);
            return 0;
        }

        if (wParam == VK_ESCAPE) {
            DestroyWindow(GetParent(hwnd));
            return 0;
        }
    }

    // Call appropriate original Button procedure
    if (hwnd == mainWin->registerBtn) {
        return CallWindowProc(originalRegisterButtonProc, hwnd, msg, wParam, lParam);
    }
    if (hwnd == mainWin->settingsBtn) {
        return CallWindowProc(originalSettingsButtonProc, hwnd, msg, wParam, lParam);
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

// Subclass procedure for ListBox to intercept key presses
LRESULT CALLBACK ListBoxSubclassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    MainWindow* mainWin = (MainWindow*)GetWindowLongPtr(GetParent(hwnd), GWLP_USERDATA);
    
    if (msg == WM_KEYDOWN && mainWin) {
        // Stop timer on any key press
        if (mainWin->timerActive) {
            StopTimer(mainWin);
        }
        
        switch (wParam) {
            case VK_RETURN: {
                // Enter - execute selected command
                int index = (int)SendMessage(hwnd, LB_GETCURSEL, 0, 0);
                if (index != LB_ERR && index < mainWin->config->commandCount) {
                    ExecuteCommand(&mainWin->config->commands[index], mainWin->url);
                    DestroyWindow(GetParent(hwnd));
                }
                return 0;
            }
            
            case VK_ESCAPE:
                DestroyWindow(GetParent(hwnd));
                return 0;
                
            case VK_TAB: {
                // Tab - switch focus to Register button
                BOOL shift = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                if (shift) {
                    // Shift+Tab -> move focus to Settings (reverse cycle)
                    SetFocus(mainWin->settingsBtn);
                } else {
                    SetFocus(mainWin->registerBtn);
                }
                return 0;
            }
        }
    }
    
    if (msg == WM_CHAR && mainWin) {
        // Stop timer on any character input
        if (mainWin->timerActive) {
            StopTimer(mainWin);
        }
        
        // Quick select 1-9
        if (wParam >= '1' && wParam <= '9') {
            int index = wParam - '1';
            if (index < mainWin->config->commandCount) {
                ExecuteCommand(&mainWin->config->commands[index], mainWin->url);
                DestroyWindow(GetParent(hwnd));
            }
            return 0;
        }
    }
    
    // Call original ListBox procedure
    return CallWindowProc(originalListBoxProc, hwnd, msg, wParam, lParam);
}

void RefreshCommandList(MainWindow* mainWin) {
    // Clear list box
    SendMessage(mainWin->listBox, LB_RESETCONTENT, 0, 0);
    
    // Add commands without numbers
    for (int i = 0; i < mainWin->config->commandCount; i++) {
        SendMessageA(mainWin->listBox, LB_ADDSTRING, 0, (LPARAM)mainWin->config->commands[i].name);
    }
    
    // Set default selection
    int sel = mainWin->config->settings.defaultCommandIndex;
    if (sel >= mainWin->config->commandCount) sel = 0;
    SendMessage(mainWin->listBox, LB_SETCURSEL, sel, 0);
}

// Timer functions
static void StartTimer(MainWindow* mainWin) {
    if (mainWin->timerActive || mainWin->config->settings.waitTime <= 0) {
        return;
    }
    
    mainWin->remainingSeconds = mainWin->config->settings.waitTime;
    mainWin->timerActive = TRUE;
    
    // Start timer (1000ms = 1 second)
    mainWin->timerId = SetTimer(mainWin->hwnd, TIMER_ID, 1000, NULL);
    
    // Update countdown display
    wchar_t countdownText[256];
    swprintf(countdownText, 256, I18n_GetStringW(IDS_COUNTDOWN_SECONDS), mainWin->remainingSeconds);
    SetWindowTextW(mainWin->countdownLabel, countdownText);
}

static void StopTimer(MainWindow* mainWin) {
    if (mainWin->timerActive && mainWin->timerId != 0) {
        KillTimer(mainWin->hwnd, mainWin->timerId);
        mainWin->timerId = 0;
        mainWin->timerActive = FALSE;
        mainWin->remainingSeconds = 0;
        
        // Clear countdown display
        SetWindowTextW(mainWin->countdownLabel, L"");
    }
}

static void UpdateCountdownDisplay(MainWindow* mainWin) {
    if (mainWin->timerActive) {
        wchar_t countdownText[256];
        if (mainWin->remainingSeconds > 1) {
            swprintf(countdownText, 256, I18n_GetStringW(IDS_COUNTDOWN_SECONDS), mainWin->remainingSeconds);
        } else if (mainWin->remainingSeconds == 1) {
            wcscpy(countdownText, I18n_GetStringW(IDS_COUNTDOWN_SECOND));
        } else {
            wcscpy(countdownText, I18n_GetStringW(IDS_COUNTDOWN_NOW));
        }
        SetWindowTextW(mainWin->countdownLabel, countdownText);
    }
}

static void ExecuteDefaultCommand(MainWindow* mainWin) {
    int defaultIndex = mainWin->config->settings.defaultCommandIndex;
    if (defaultIndex >= 0 && defaultIndex < mainWin->config->commandCount) {
        ExecuteCommand(&mainWin->config->commands[defaultIndex], mainWin->url);
    }
    DestroyWindow(mainWin->hwnd);
}

HWND CreateMainWindow(HINSTANCE hInstance, Configuration* config, const char* url, const char* exePath) {
    // Register window class
    WNDCLASSEXW wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEXW);
    wc.lpfnWndProc = MainWindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"BrowserSelectorClass";
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(1));
    wc.hIconSm = LoadIcon(hInstance, MAKEINTRESOURCE(1));
    
    if (!RegisterClassExW(&wc)) {
        // Class may already be registered
        DWORD err = GetLastError();
        if (err != ERROR_CLASS_ALREADY_EXISTS) {
            return NULL;
        }
    }
    
    // Create window data structure
    MainWindow* mainWin = (MainWindow*)malloc(sizeof(MainWindow));
    if (!mainWin) return NULL;
    
    ZeroMemory(mainWin, sizeof(MainWindow));
    mainWin->config = config;
    mainWin->url = url ? _strdup(url) : NULL;
    mainWin->hInstance = hInstance;
    strncpy(mainWin->exePath, exePath, MAX_PATH - 1);
    
    // Initialize timer fields
    mainWin->timerId = 0;
    mainWin->timerActive = FALSE;
    mainWin->remainingSeconds = 0;
    
    // Calculate window position (center screen) using hard-coded constants
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int winX = (screenWidth - MAIN_WINDOW_WIDTH) / 2;
    int winY = (screenHeight - MAIN_WINDOW_HEIGHT) / 2;
    
    // Create window
    HWND hwnd = CreateWindowExW(
        WS_EX_APPWINDOW,
        L"BrowserSelectorClass",
        I18n_GetStringW(IDS_APP_TITLE),
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,
        winX, winY,
        MAIN_WINDOW_WIDTH,
        MAIN_WINDOW_HEIGHT,
        NULL, NULL, hInstance, mainWin
    );
    
    if (!hwnd) {
        if (mainWin->url) free(mainWin->url);
        free(mainWin);
        return NULL;
    }
    
    return hwnd;
}

LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    MainWindow* mainWin = (MainWindow*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (msg) {
        case WM_CREATE: {
            CREATESTRUCT* cs = (CREATESTRUCT*)lParam;
            mainWin = (MainWindow*)cs->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)mainWin);
            mainWin->hwnd = hwnd;
            
            // Get client rect for positioning
            RECT clientRect;
            GetClientRect(hwnd, &clientRect);
            int clientWidth = clientRect.right - clientRect.left;
            int clientHeight = clientRect.bottom - clientRect.top;
            
            // Create countdown label (positioned above ListBox)
            mainWin->countdownLabel = CreateWindowExA(
                0,
                "STATIC",
                "",
                WS_CHILD | WS_VISIBLE | SS_CENTER,
                10, 5,
                clientWidth - 20, 20,
                hwnd, (HMENU)ID_COUNTDOWN_LABEL, cs->hInstance, NULL
            );
            
            // Create ListBox (positioned below countdown label)
            mainWin->listBox = CreateWindowExA(
                WS_EX_CLIENTEDGE,
                "LISTBOX",
                NULL,
                WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP |
                LBS_NOTIFY | LBS_NOINTEGRALHEIGHT,
                10, 30,
                clientWidth - 20,
                clientHeight - 80,
                hwnd, (HMENU)ID_LISTBOX, cs->hInstance, NULL
            );
            
            // Set font
            HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            SendMessage(mainWin->listBox, WM_SETFONT, (WPARAM)hFont, TRUE);
            SendMessage(mainWin->countdownLabel, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            // Subclass ListBox to intercept key presses
            originalListBoxProc = (WNDPROC)SetWindowLongPtr(mainWin->listBox, 
                GWLP_WNDPROC, (LONG_PTR)ListBoxSubclassProc);
            
            // Fill ListBox with commands
            RefreshCommandList(mainWin);
            
            // Create buttons (Register and Settings)
            int btnWidth = 160;  // Increased from 100 to accommodate longer text
            int btnHeight = 30;
            int btnSpacing = 10;
            int totalWidth = btnWidth * 2 + btnSpacing;
            int btnStartX = (clientWidth - totalWidth) / 2;
            int btnY = clientHeight - btnHeight - 10;
            
            // Create Register/Unregister button (left)
            BOOL isRegistered = IsRegisteredAsBrowser();
            BOOL isDefault = IsDefaultBrowser();
            const wchar_t* registerBtnText = (isRegistered && isDefault) ? 
                I18n_GetStringW(IDS_UNREGISTER_BTN) : I18n_GetStringW(IDS_SET_DEFAULT_BTN);
            
            mainWin->registerBtn = CreateWindowExW(
                0,
                L"BUTTON",
                registerBtnText,
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                btnStartX, btnY, btnWidth, btnHeight,
                hwnd, (HMENU)ID_REGISTER_BTN, cs->hInstance, NULL
            );
            SendMessage(mainWin->registerBtn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            // Create Settings button (right)
            mainWin->settingsBtn = CreateWindowExW(
                0,
                L"BUTTON",
                I18n_GetStringW(IDS_SETTINGS_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                btnStartX + btnWidth + btnSpacing, btnY, btnWidth, btnHeight,
                hwnd, (HMENU)ID_SETTINGS_BTN, cs->hInstance, NULL
            );
            SendMessage(mainWin->settingsBtn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            // Subclass Register and Settings buttons to intercept Tab key
            originalRegisterButtonProc = (WNDPROC)SetWindowLongPtr(mainWin->registerBtn,
                GWLP_WNDPROC, (LONG_PTR)ButtonSubclassProc);
            originalSettingsButtonProc = (WNDPROC)SetWindowLongPtr(mainWin->settingsBtn,
                GWLP_WNDPROC, (LONG_PTR)ButtonSubclassProc);
            
            // Set focus to ListBox
            SetFocus(mainWin->listBox);
            
            // Start auto-open timer if waitTime is configured
            if (mainWin->config->settings.waitTime > 0) {
                StartTimer(mainWin);
            }
            
            return 0;
        }
        
        case WM_COMMAND: {
            if (!mainWin) break;
            
            switch (LOWORD(wParam)) {
                case ID_LISTBOX:
                    if (HIWORD(wParam) == LBN_DBLCLK) {
                        // Stop timer on user interaction
                        if (mainWin->timerActive) {
                            StopTimer(mainWin);
                        }
                        
                        // Double click - execute command
                        int index = (int)SendMessage(mainWin->listBox, LB_GETCURSEL, 0, 0);
                        if (index != LB_ERR && index < mainWin->config->commandCount) {
                            ExecuteCommand(&mainWin->config->commands[index], mainWin->url);
                            DestroyWindow(hwnd);
                        }
                    }
                    break;
                    
                case ID_REGISTER_BTN: {
                    // Stop timer on user interaction
                    if (mainWin->timerActive) {
                        StopTimer(mainWin);
                    }
                    
                    // Check current state
                    BOOL isRegistered = IsRegisteredAsBrowser();
                    BOOL isDefault = IsDefaultBrowser();
                    
                    if (isRegistered && isDefault) {
                        // Unregister completely
                        if (UnregisterAsBrowser()) {
                            MessageBoxW(hwnd, 
                                I18n_GetStringW(IDS_UNREG_SUCCESS_MSG),
                                I18n_GetStringW(IDS_UNREG_SUCCESS_TITLE), 
                                MB_OK | MB_ICONINFORMATION);
                            SetWindowTextW(mainWin->registerBtn, I18n_GetStringW(IDS_SET_DEFAULT_BTN));
                        } else {
                            MessageBoxW(hwnd, 
                                I18n_GetStringW(IDS_UNREG_FAILED_MSG),
                                I18n_GetStringW(IDS_UNREG_FAILED_TITLE), 
                                MB_OK | MB_ICONERROR);
                        }
                    } else {
                        // Register and set as default
                        BOOL success = TRUE;
                        
                        if (!isRegistered) {
                            // First register
                            success = RegisterAsBrowser(mainWin->exePath);
                            if (!success) {
                                MessageBoxW(hwnd, 
                                    I18n_GetStringW(IDS_REG_FAILED_MSG),
                                    I18n_GetStringW(IDS_REG_FAILED_TITLE), 
                                    MB_OK | MB_ICONERROR);
                            }
                        }
                        
                        if (success) {
                            // Try to set as default (now with automatic hash method)
                            BOOL setDefault = SetAsDefaultBrowser();
                            
                            if (setDefault) {
                                MessageBoxW(hwnd, 
                                    I18n_GetStringW(IDS_REG_SUCCESS_MSG),
                                    I18n_GetStringW(IDS_REG_SUCCESS_TITLE), 
                                    MB_OK | MB_ICONINFORMATION);
                                SetWindowTextW(mainWin->registerBtn, I18n_GetStringW(IDS_UNREGISTER_BTN));
                            } else {
                                // Settings opened - user needs to complete manually
                                int result = MessageBoxW(hwnd,
                                    I18n_GetStringW(IDS_VERIFY_MSG),
                                    I18n_GetStringW(IDS_VERIFY_TITLE),
                                    MB_YESNO | MB_ICONQUESTION);
                                
                                if (result == IDYES) {
                                    // Re-check status
                                    if (IsDefaultBrowser()) {
                                        MessageBoxW(hwnd,
                                            I18n_GetStringW(IDS_NOW_DEFAULT_MSG),
                                            I18n_GetStringW(IDS_SUCCESS),
                                            MB_OK | MB_ICONINFORMATION);
                                        SetWindowTextW(mainWin->registerBtn, I18n_GetStringW(IDS_UNREGISTER_BTN));
                                    } else {
                                        MessageBoxW(hwnd,
                                            I18n_GetStringW(IDS_NOT_DEFAULT_MSG),
                                            I18n_GetStringW(IDS_WARNING),
                                            MB_OK | MB_ICONWARNING);
                                    }
                                }
                            }
                        }
                    }
                    SetFocus(mainWin->listBox);
                    break;
                }
                    
                case ID_SETTINGS_BTN:
                    // Stop timer on user interaction
                    if (mainWin->timerActive) {
                        StopTimer(mainWin);
                    }
                    
                    // Open settings window
                    if (ShowSettingsWindow(hwnd, mainWin->config, mainWin->exePath)) {
                        // Settings changed, refresh list
                        RefreshCommandList(mainWin);
                    }
                    SetFocus(mainWin->listBox);
                    break;
            }
            return 0;
        }
        
        case WM_TIMER: {
            if (wParam == TIMER_ID && mainWin && mainWin->timerActive) {
                mainWin->remainingSeconds--;
                
                if (mainWin->remainingSeconds <= 0) {
                    // Timer reached zero - execute default command
                    StopTimer(mainWin);
                    ExecuteDefaultCommand(mainWin);
                } else {
                    // Update countdown display
                    UpdateCountdownDisplay(mainWin);
                }
            }
            return 0;
        }
        
        case WM_ACTIVATE: {
            if (LOWORD(wParam) != WA_INACTIVE && mainWin && mainWin->listBox) {
                // Use PostMessage to set focus after window activation is complete
                // This ensures keyboard input works correctly after Alt+Tab
                PostMessage(hwnd, WM_USER + 1, 0, 0);
            }
            break;
        }
        
        case WM_USER + 1: {
            // Set focus to ListBox (delayed from WM_ACTIVATE)
            if (mainWin && mainWin->listBox) {
                SetFocus(mainWin->listBox);
            }
            return 0;
        }
        
        case WM_DESTROY: {
            // Clean up timer
            if (mainWin && mainWin->timerActive) {
                StopTimer(mainWin);
            }
            
            if (mainWin) {
                if (mainWin->url) free(mainWin->url);
                free(mainWin);
            }
            PostQuitMessage(0);
            return 0;
        }
    }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

```

// FILE: src/ui/mainwindow.h
```
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <windows.h>
#include "../config/config.h"

typedef struct {
    HWND hwnd;
    HWND listBox;
    HWND registerBtn;
    HWND settingsBtn;
    HWND countdownLabel;  // Label for countdown display
    Configuration* config;
    char* url;
    char exePath[MAX_PATH];
    HINSTANCE hInstance;
    
    // Timer fields
    UINT_PTR timerId;
    int remainingSeconds;
    BOOL timerActive;
} MainWindow;

// Create and show main window
HWND CreateMainWindow(HINSTANCE hInstance, Configuration* config, const char* url, const char* exePath);

// Window procedure
LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Refresh list box with current commands
void RefreshCommandList(MainWindow* mainWin);

#endif // MAINWINDOW_H

```

// FILE: src/ui/settings.c
```
#include "settings.h"
#include "commandeditor.h"
#include "../config/config.h"
#include "../i18n/i18n.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <commctrl.h>

#define ID_COMMAND_LIST 3001
#define ID_ADD_BTN 3002
#define ID_EDIT_BTN 3003
#define ID_DELETE_BTN 3004
#define ID_MOVE_UP_BTN 3005
#define ID_MOVE_DOWN_BTN 3006
#define ID_SET_DEFAULT_BTN 3007
#define ID_CLOSE_BTN 3008
#define ID_WAITTIME_LABEL 3009
#define ID_WAITTIME_EDIT 3010
#define ID_WAITTIME_SPIN 3011

typedef struct {
    Configuration* config;
    const char* exePath;
    HWND listBox;
    HWND waitTimeEdit;
    HWND waitTimeSpin;
    BOOL changed;
} SettingsData;


static void RefreshSettingsList(SettingsData* data) {
    SendMessage(data->listBox, LB_RESETCONTENT, 0, 0);
    
    for (int i = 0; i < data->config->commandCount; i++) {
        wchar_t itemText[MAX_NAME_LENGTH + 40];
        wchar_t wideName[MAX_NAME_LENGTH];
        
        // Convert name to wide string
        MultiByteToWideChar(CP_ACP, 0, data->config->commands[i].name, -1, wideName, MAX_NAME_LENGTH);
        
        if (i == data->config->settings.defaultCommandIndex) {
            swprintf(itemText, sizeof(itemText)/sizeof(wchar_t), L"%s %s", 
                    wideName, I18n_GetStringW(IDS_DEFAULT_MARKER));
        } else {
            wcscpy(itemText, wideName);
        }
        SendMessageW(data->listBox, LB_ADDSTRING, 0, (LPARAM)itemText);
    }
}

static void SwapCommands(Configuration* config, int idx1, int idx2) {
    Command temp = config->commands[idx1];
    config->commands[idx1] = config->commands[idx2];
    config->commands[idx2] = temp;
    
    // Update default index if needed
    if (config->settings.defaultCommandIndex == idx1) {
        config->settings.defaultCommandIndex = idx2;
    } else if (config->settings.defaultCommandIndex == idx2) {
        config->settings.defaultCommandIndex = idx1;
    }
}

LRESULT CALLBACK SettingsWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    SettingsData* data = (SettingsData*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (msg) {
        case WM_CREATE: {
            CREATESTRUCT* cs = (CREATESTRUCT*)lParam;
            data = (SettingsData*)cs->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)data);
            
            HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            
            // List box for commands
            data->listBox = CreateWindowExW(
                WS_EX_CLIENTEDGE,
                L"LISTBOX",
                NULL,
                WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP |
                LBS_NOTIFY | LBS_NOINTEGRALHEIGHT,
                10, 10, 280, 180,
                hwnd, (HMENU)ID_COMMAND_LIST, cs->hInstance, NULL
            );
            SendMessage(data->listBox, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            // WaitTime controls
            HWND waitTimeLabel = CreateWindowExW(
                0, L"STATIC", I18n_GetStringW(IDS_WAITTIME_LABEL),
                WS_CHILD | WS_VISIBLE,
                10, 200, 150, 20,
                hwnd, (HMENU)ID_WAITTIME_LABEL, cs->hInstance, NULL
            );
            SendMessage(waitTimeLabel, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            data->waitTimeEdit = CreateWindowExW(
                WS_EX_CLIENTEDGE, L"EDIT", L"",
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_NUMBER | ES_AUTOHSCROLL,
                170, 200, 50, 20,
                hwnd, (HMENU)ID_WAITTIME_EDIT, cs->hInstance, NULL
            );
            SendMessage(data->waitTimeEdit, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            // Create spin control
            data->waitTimeSpin = CreateWindowExW(
                0, UPDOWN_CLASSW, NULL,
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | UDS_ALIGNRIGHT | UDS_ARROWKEYS | UDS_SETBUDDYINT | UDS_NOTHOUSANDS,
                220, 200, 20, 20,
                hwnd, (HMENU)ID_WAITTIME_SPIN, cs->hInstance, NULL
            );
            SendMessage(data->waitTimeSpin, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            // Set spin control range and buddy
            SendMessage(data->waitTimeSpin, UDM_SETRANGE, 0, MAKELONG(10, 1)); // Min=1, Max=10
            SendMessage(data->waitTimeSpin, UDM_SETBUDDY, (WPARAM)data->waitTimeEdit, 0);
            SendMessage(data->waitTimeSpin, UDM_SETPOS, 0, MAKELONG(data->config->settings.waitTime, 0));
            
            // Buttons
            int btnX = 300;
            int btnWidth = 90;
            int btnHeight = 26;
            int btnSpacing = 32;
            
            HWND btn = CreateWindowExW(0, L"BUTTON", I18n_GetStringW(IDS_ADD_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                btnX, 10, btnWidth, btnHeight,
                hwnd, (HMENU)ID_ADD_BTN, cs->hInstance, NULL);
            SendMessage(btn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            btn = CreateWindowExW(0, L"BUTTON", I18n_GetStringW(IDS_EDIT_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                btnX, 10 + btnSpacing, btnWidth, btnHeight,
                hwnd, (HMENU)ID_EDIT_BTN, cs->hInstance, NULL);
            SendMessage(btn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            btn = CreateWindowExW(0, L"BUTTON", I18n_GetStringW(IDS_DELETE_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                btnX, 10 + btnSpacing * 2, btnWidth, btnHeight,
                hwnd, (HMENU)ID_DELETE_BTN, cs->hInstance, NULL);
            SendMessage(btn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            btn = CreateWindowExW(0, L"BUTTON", I18n_GetStringW(IDS_MOVE_UP_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                btnX, 10 + btnSpacing * 3, btnWidth, btnHeight,
                hwnd, (HMENU)ID_MOVE_UP_BTN, cs->hInstance, NULL);
            SendMessage(btn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            btn = CreateWindowExW(0, L"BUTTON", I18n_GetStringW(IDS_MOVE_DOWN_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                btnX, 10 + btnSpacing * 4, btnWidth, btnHeight,
                hwnd, (HMENU)ID_MOVE_DOWN_BTN, cs->hInstance, NULL);
            SendMessage(btn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            btn = CreateWindowExW(0, L"BUTTON", I18n_GetStringW(IDS_SET_DEFAULT_CMD_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                btnX, 10 + btnSpacing * 5, btnWidth, btnHeight,
                hwnd, (HMENU)ID_SET_DEFAULT_BTN, cs->hInstance, NULL);
            SendMessage(btn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            btn = CreateWindowExW(0, L"BUTTON", I18n_GetStringW(IDS_CLOSE_BTN),
                WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON,
                btnX, 220 - btnHeight, btnWidth, btnHeight,
                hwnd, (HMENU)ID_CLOSE_BTN, cs->hInstance, NULL);
            SendMessage(btn, WM_SETFONT, (WPARAM)hFont, TRUE);
            
            // Fill list
            RefreshSettingsList(data);
            
            if (data->config->commandCount > 0) {
                SendMessage(data->listBox, LB_SETCURSEL, 0, 0);
            }
            
            SetFocus(data->listBox);
            
            return 0;
        }
        
        case WM_COMMAND: {
            if (!data) break;
            
            int sel = (int)SendMessage(data->listBox, LB_GETCURSEL, 0, 0);
            
            // Handle WaitTime edit control
            if (LOWORD(wParam) == ID_WAITTIME_EDIT) {
                if (HIWORD(wParam) == EN_CHANGE) {
                    char buffer[10];
                    GetWindowTextA(data->waitTimeEdit, buffer, sizeof(buffer));
                    
                    int waitTime = atoi(buffer);
                    if (waitTime < 1) {
                        waitTime = 1;
                        snprintf(buffer, sizeof(buffer), "%d", waitTime);
                        SetWindowTextA(data->waitTimeEdit, buffer);
                        SendMessage(data->waitTimeSpin, UDM_SETPOS, 0, MAKELONG(waitTime, 0));
                    } else if (waitTime > 10) {
                        waitTime = 10;
                        snprintf(buffer, sizeof(buffer), "%d", waitTime);
                        SetWindowTextA(data->waitTimeEdit, buffer);
                        SendMessage(data->waitTimeSpin, UDM_SETPOS, 0, MAKELONG(waitTime, 0));
                    }
                    
                    if (waitTime != data->config->settings.waitTime) {
                        data->config->settings.waitTime = waitTime;
                        data->changed = TRUE;
                        SaveConfig(data->exePath, data->config);
                    }
                }
                return 0;
            }
            
            // Handle WaitTime spin control
            if (LOWORD(wParam) == ID_WAITTIME_SPIN) {
                // Spin control changes are handled through the buddy edit control
                return 0;
            }
            
            switch (LOWORD(wParam)) {
                case ID_COMMAND_LIST:
                    if (HIWORD(wParam) == LBN_DBLCLK) {
                        // Double click - edit
                        if (sel != LB_ERR && sel < data->config->commandCount) {
                            if (ShowCommandEditor(hwnd, &data->config->commands[sel], FALSE)) {
                                data->changed = TRUE;
                                SaveConfig(data->exePath, data->config);
                                RefreshSettingsList(data);
                                SendMessage(data->listBox, LB_SETCURSEL, sel, 0);
                            }
                        }
                    }
                    break;
                    
                case ID_ADD_BTN: {
                    if (data->config->commandCount >= MAX_COMMANDS) {
                        MessageBoxW(hwnd, I18n_GetStringW(IDS_MAX_COMMANDS_WARNING), 
                                   I18n_GetStringW(IDS_WARNING), MB_OK | MB_ICONWARNING);
                        break;
                    }
                    
                    Command newCmd;
                    ZeroMemory(&newCmd, sizeof(newCmd));
                    strcpy(newCmd.command, "{url}");
                    
                    if (ShowCommandEditor(hwnd, &newCmd, TRUE)) {
                        data->config->commands[data->config->commandCount] = newCmd;
                        data->config->commandCount++;
                        data->changed = TRUE;
                        SaveConfig(data->exePath, data->config);
                        RefreshSettingsList(data);
                        SendMessage(data->listBox, LB_SETCURSEL, data->config->commandCount - 1, 0);
                    }
                    SetFocus(data->listBox);
                    break;
                }
                
                case ID_EDIT_BTN: {
                    if (sel != LB_ERR && sel < data->config->commandCount) {
                        if (ShowCommandEditor(hwnd, &data->config->commands[sel], FALSE)) {
                            data->changed = TRUE;
                            SaveConfig(data->exePath, data->config);
                            RefreshSettingsList(data);
                            SendMessage(data->listBox, LB_SETCURSEL, sel, 0);
                        }
                    }
                    SetFocus(data->listBox);
                    break;
                }
                
                case ID_DELETE_BTN: {
                    if (sel != LB_ERR && sel < data->config->commandCount) {
                        wchar_t msg[512];
                        wchar_t wideName[MAX_NAME_LENGTH];
                        MultiByteToWideChar(CP_ACP, 0, data->config->commands[sel].name, -1, wideName, MAX_NAME_LENGTH);
                        
                        swprintf(msg, sizeof(msg)/sizeof(wchar_t), I18n_GetStringW(IDS_CONFIRM_DELETE_MSG), wideName);
                        
                        if (MessageBoxW(hwnd, msg, I18n_GetStringW(IDS_CONFIRM_DELETE_TITLE), 
                                       MB_YESNO | MB_ICONQUESTION) == IDYES) {
                            // Shift remaining commands
                            for (int i = sel; i < data->config->commandCount - 1; i++) {
                                data->config->commands[i] = data->config->commands[i + 1];
                            }
                            data->config->commandCount--;
                            
                            // Adjust default index
                            if (data->config->settings.defaultCommandIndex >= data->config->commandCount) {
                                data->config->settings.defaultCommandIndex = data->config->commandCount > 0 ? data->config->commandCount - 1 : 0;
                            } else if (data->config->settings.defaultCommandIndex > sel) {
                                data->config->settings.defaultCommandIndex--;
                            }
                            
                            data->changed = TRUE;
                            SaveConfig(data->exePath, data->config);
                            RefreshSettingsList(data);
                            
                            if (sel >= data->config->commandCount) sel = data->config->commandCount - 1;
                            if (sel >= 0) SendMessage(data->listBox, LB_SETCURSEL, sel, 0);
                        }
                    }
                    SetFocus(data->listBox);
                    break;
                }
                
                case ID_MOVE_UP_BTN: {
                    if (sel > 0 && sel < data->config->commandCount) {
                        SwapCommands(data->config, sel, sel - 1);
                        data->changed = TRUE;
                        SaveConfig(data->exePath, data->config);
                        RefreshSettingsList(data);
                        SendMessage(data->listBox, LB_SETCURSEL, sel - 1, 0);
                    }
                    SetFocus(data->listBox);
                    break;
                }
                
                case ID_MOVE_DOWN_BTN: {
                    if (sel >= 0 && sel < data->config->commandCount - 1) {
                        SwapCommands(data->config, sel, sel + 1);
                        data->changed = TRUE;
                        SaveConfig(data->exePath, data->config);
                        RefreshSettingsList(data);
                        SendMessage(data->listBox, LB_SETCURSEL, sel + 1, 0);
                    }
                    SetFocus(data->listBox);
                    break;
                }
                
                case ID_SET_DEFAULT_BTN: {
                    if (sel != LB_ERR && sel < data->config->commandCount) {
                        data->config->settings.defaultCommandIndex = sel;
                        data->changed = TRUE;
                        SaveConfig(data->exePath, data->config);
                        RefreshSettingsList(data);
                        SendMessage(data->listBox, LB_SETCURSEL, sel, 0);
                    }
                    SetFocus(data->listBox);
                    break;
                }
                
                case ID_CLOSE_BTN:
                    DestroyWindow(hwnd);
                    break;
            }
            return 0;
        }
        
        case WM_KEYDOWN: {
            if (wParam == VK_ESCAPE) {
                DestroyWindow(hwnd);
                return 0;
            }
            break;
        }
        
        case WM_CLOSE: {
            DestroyWindow(hwnd);
            return 0;
        }
        
        case WM_DESTROY: {
            PostQuitMessage(0);
            return 0;
        }
    }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

BOOL ShowSettingsWindow(HWND parent, Configuration* config, const char* exePath) {
    HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(parent, GWLP_HINSTANCE);
    
    // Register window class
    WNDCLASSEXW wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEXW);
    wc.lpfnWndProc = SettingsWindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"SettingsWindowClass";
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    
    RegisterClassExW(&wc);
    
    // Prepare data
    SettingsData data;
    data.config = config;
    data.exePath = exePath;
    data.changed = FALSE;
    
    // Calculate position
    RECT parentRect;
    GetWindowRect(parent, &parentRect);
    int winWidth = 410;
    int winHeight = 290;
    int winX = parentRect.left + (parentRect.right - parentRect.left - winWidth) / 2;
    int winY = parentRect.top + (parentRect.bottom - parentRect.top - winHeight) / 2;
    
    // Create window
    HWND hwnd = CreateWindowExW(
        WS_EX_DLGMODALFRAME | WS_EX_TOPMOST,
        L"SettingsWindowClass",
        I18n_GetStringW(IDS_SETTINGS_TITLE),
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
        winX, winY, winWidth, winHeight,
        parent, NULL, hInstance, &data
    );
    
    if (!hwnd) return FALSE;
    
    // Disable parent window
    EnableWindow(parent, FALSE);
    
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);
    
    // Modal message loop
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!IsDialogMessage(hwnd, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    // Re-enable parent
    EnableWindow(parent, TRUE);
    SetForegroundWindow(parent);
    
    return data.changed;
}

```

// FILE: src/ui/settings.h
```
#ifndef SETTINGS_H
#define SETTINGS_H

#include <windows.h>
#include "../config/config.h"

// Show settings dialog
// Returns TRUE if settings were changed
BOOL ShowSettingsWindow(HWND parent, Configuration* config, const char* exePath);

// Settings window procedure
LRESULT CALLBACK SettingsWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#endif // SETTINGS_H

```

